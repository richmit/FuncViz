<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: mjr::MRPTree&lt; maxDepth, domRngBaseT, domDim, rngDim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mjr</b></li><li class="navelem"><a class="el" href="classmjr_1_1_m_r_p_tree.html">MRPTree</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classmjr_1_1_m_r_p_tree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mjr::MRPTree&lt; maxDepth, domRngBaseT, domDim, rngDim &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Template Class used to house an <a class="el" href="classmjr_1_1_m_r_p_tree.html" title="Template Class used to house an MRPTree.">MRPTree</a>.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_m_r_p_tree_8hpp_source.html">MRPTree.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af7dd7a32cbad34b0e20a31cd7a1aec52" id="r_af7dd7a32cbad34b0e20a31cd7a1aec52"><td class="memItemLeft" align="right" valign="top">typedef std::conditional&lt; std::cmp_equal(domDim, 1), domRngBaseT, std::vector&lt; domRngBaseT &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a></td></tr>
<tr class="memdesc:af7dd7a32cbad34b0e20a31cd7a1aec52"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type used to hold values in the domain space of our tree.  <br /></td></tr>
<tr class="separator:af7dd7a32cbad34b0e20a31cd7a1aec52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac027b17fe9c8751b7faf9be6dea76a7c" id="r_ac027b17fe9c8751b7faf9be6dea76a7c"><td class="memItemLeft" align="right" valign="top"><a id="ac027b17fe9c8751b7faf9be6dea76a7c" name="ac027b17fe9c8751b7faf9be6dea76a7c"></a>
typedef std::vector&lt; domRngBaseT &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>domainVectorT</b></td></tr>
<tr class="memdesc:ac027b17fe9c8751b7faf9be6dea76a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector used to hold values in the domain space of our tree. <br /></td></tr>
<tr class="separator:ac027b17fe9c8751b7faf9be6dea76a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd5d4c5318f6fedf507ea075d22bcf2" id="r_abbd5d4c5318f6fedf507ea075d22bcf2"><td class="memItemLeft" align="right" valign="top">typedef std::conditional&lt; std::cmp_equal(rngDim, 1), domRngBaseT, std::vector&lt; domRngBaseT &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a></td></tr>
<tr class="memdesc:abbd5d4c5318f6fedf507ea075d22bcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type used to hold values in the range space of our tree.  <br /></td></tr>
<tr class="separator:abbd5d4c5318f6fedf507ea075d22bcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd496b12394781f40294fb4375a1fee7" id="r_abd496b12394781f40294fb4375a1fee7"><td class="memItemLeft" align="right" valign="top"><a id="abd496b12394781f40294fb4375a1fee7" name="abd496b12394781f40294fb4375a1fee7"></a>
typedef std::vector&lt; domRngBaseT &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>rangeVectorT</b></td></tr>
<tr class="memdesc:abd496b12394781f40294fb4375a1fee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector used to hold values in the range space of our tree. <br /></td></tr>
<tr class="separator:abd496b12394781f40294fb4375a1fee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9276573dd0bb3afc7b20dbf9a781d45" id="r_ae9276573dd0bb3afc7b20dbf9a781d45"><td class="memItemLeft" align="right" valign="top">typedef iCrdCmpIntT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a></td></tr>
<tr class="memdesc:ae9276573dd0bb3afc7b20dbf9a781d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned integer type large enough to hold a single component of an integer coordinate tuple.  <br /></td></tr>
<tr class="separator:ae9276573dd0bb3afc7b20dbf9a781d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada13ac2ded350dced113d94e52264fa1" id="r_ada13ac2ded350dced113d94e52264fa1"><td class="memItemLeft" align="right" valign="top"><a id="ada13ac2ded350dced113d94e52264fa1" name="ada13ac2ded350dced113d94e52264fa1"></a>
typedef iiCrdTupIntT&#160;</td><td class="memItemRight" valign="bottom"><b>iiCrdTupT</b></td></tr>
<tr class="memdesc:ada13ac2ded350dced113d94e52264fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned integer type large enough to hold a complete integer coordinate tuple. <br /></td></tr>
<tr class="separator:ada13ac2ded350dced113d94e52264fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8008bf1a2994bb4cd2762b0eed8c74" id="r_a0b8008bf1a2994bb4cd2762b0eed8c74"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b8008bf1a2994bb4cd2762b0eed8c74">viCrdTupT</a></td></tr>
<tr class="memdesc:a0b8008bf1a2994bb4cd2762b0eed8c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector holding integer coordinate components &ndash; i.e.  <br /></td></tr>
<tr class="separator:a0b8008bf1a2994bb4cd2762b0eed8c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7b92c9825ca9127c2763b8356a8042" id="r_a8d7b92c9825ca9127c2763b8356a8042"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a></td></tr>
<tr class="memdesc:a8d7b92c9825ca9127c2763b8356a8042"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::vector used to pass lists of iiCrdTupT types around.  <br /></td></tr>
<tr class="separator:a8d7b92c9825ca9127c2763b8356a8042"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a7011eb700b6135191e253b4d2ef2277e" id="r_a7011eb700b6135191e253b4d2ef2277e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7011eb700b6135191e253b4d2ef2277e">MRPTree</a> ()</td></tr>
<tr class="memdesc:a7011eb700b6135191e253b4d2ef2277e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set real coordinate &amp; aspect ratio to defaults.  <br /></td></tr>
<tr class="separator:a7011eb700b6135191e253b4d2ef2277e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32297f16fbf8ef677134ad41e74b9f45" id="r_a32297f16fbf8ef677134ad41e74b9f45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32297f16fbf8ef677134ad41e74b9f45">MRPTree</a> (<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a> newBBoxMin, <a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a> newBBoxMax)</td></tr>
<tr class="memdesc:a32297f16fbf8ef677134ad41e74b9f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set real coordinate as specified &amp; aspect ratio to default.  <br /></td></tr>
<tr class="separator:a32297f16fbf8ef677134ad41e74b9f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716e85eae67d49746277568a9812aa6e" id="r_a716e85eae67d49746277568a9812aa6e"><td class="memItemLeft" align="right" valign="top"><a id="a716e85eae67d49746277568a9812aa6e" name="a716e85eae67d49746277568a9812aa6e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MRPTree</b> (<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a> newBBoxMin, <a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a> newBBoxMax, <a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a> newAspect)</td></tr>
<tr class="memdesc:a716e85eae67d49746277568a9812aa6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set real coordinate &amp; aspect ratio as specified. <br /></td></tr>
<tr class="separator:a716e85eae67d49746277568a9812aa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction Helpers</div></td></tr>
<tr class="memitem:a2118796be825de409db28fc39b8e1ef5" id="r_a2118796be825de409db28fc39b8e1ef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2118796be825de409db28fc39b8e1ef5">setBBox</a> (<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a> newBBoxMin, <a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a> newBBoxMax)</td></tr>
<tr class="memdesc:a2118796be825de409db28fc39b8e1ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounding box.  <br /></td></tr>
<tr class="separator:a2118796be825de409db28fc39b8e1ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0709df9d096eccbebb6b4472820205e1" id="r_a0709df9d096eccbebb6b4472820205e1"><td class="memItemLeft" align="right" valign="top"><a id="a0709df9d096eccbebb6b4472820205e1" name="a0709df9d096eccbebb6b4472820205e1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setBBoxDefault</b> ()</td></tr>
<tr class="memdesc:a0709df9d096eccbebb6b4472820205e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounding box to the default: -1 for all minimum components and +1 for all maximum components. <br /></td></tr>
<tr class="separator:a0709df9d096eccbebb6b4472820205e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a51cf6c090035d9d9abc87b76c455d" id="r_a14a51cf6c090035d9d9abc87b76c455d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14a51cf6c090035d9d9abc87b76c455d">setBBoxMin</a> (<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a> newBBoxMin)</td></tr>
<tr class="memdesc:a14a51cf6c090035d9d9abc87b76c455d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounding box minimum.  <br /></td></tr>
<tr class="separator:a14a51cf6c090035d9d9abc87b76c455d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187d3e2d55a8cd8da362ed63944f092d" id="r_a187d3e2d55a8cd8da362ed63944f092d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a187d3e2d55a8cd8da362ed63944f092d">setBBoxMax</a> (<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a> newBBoxMax)</td></tr>
<tr class="memdesc:a187d3e2d55a8cd8da362ed63944f092d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounding box maxDepth.  <br /></td></tr>
<tr class="separator:a187d3e2d55a8cd8da362ed63944f092d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9671e434f8cbcceb8022e28be0c2ae5f" id="r_a9671e434f8cbcceb8022e28be0c2ae5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9671e434f8cbcceb8022e28be0c2ae5f">setAspect</a> (<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a> newAspect)</td></tr>
<tr class="memdesc:a9671e434f8cbcceb8022e28be0c2ae5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the aspect ratio.  <br /></td></tr>
<tr class="separator:a9671e434f8cbcceb8022e28be0c2ae5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c8c7d6d1cc1783b743a55af2edd1e2" id="r_ad2c8c7d6d1cc1783b743a55af2edd1e2"><td class="memItemLeft" align="right" valign="top"><a id="ad2c8c7d6d1cc1783b743a55af2edd1e2" name="ad2c8c7d6d1cc1783b743a55af2edd1e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setAspectDefault</b> ()</td></tr>
<tr class="memdesc:ad2c8c7d6d1cc1783b743a55af2edd1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the aspect ratio to the default: 1.0 for all components. <br /></td></tr>
<tr class="separator:ad2c8c7d6d1cc1783b743a55af2edd1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic Class Info</div></td></tr>
<tr class="memitem:a5c8c49672d04cae66ddf87a583e379f0" id="r_a5c8c49672d04cae66ddf87a583e379f0"><td class="memItemLeft" align="right" valign="top"><a id="a5c8c49672d04cae66ddf87a583e379f0" name="a5c8c49672d04cae66ddf87a583e379f0"></a>
<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getBBoxMin</b> () const</td></tr>
<tr class="memdesc:a5c8c49672d04cae66ddf87a583e379f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounding box minimum point. <br /></td></tr>
<tr class="separator:a5c8c49672d04cae66ddf87a583e379f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674bf11ef232672b7bd752d905f6d517" id="r_a674bf11ef232672b7bd752d905f6d517"><td class="memItemLeft" align="right" valign="top"><a id="a674bf11ef232672b7bd752d905f6d517" name="a674bf11ef232672b7bd752d905f6d517"></a>
<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getBBoxMax</b> () const</td></tr>
<tr class="memdesc:a674bf11ef232672b7bd752d905f6d517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounding box minimum point. <br /></td></tr>
<tr class="separator:a674bf11ef232672b7bd752d905f6d517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af285721a1a58d67cc4e23c156fd54a59" id="r_af285721a1a58d67cc4e23c156fd54a59"><td class="memItemLeft" align="right" valign="top"><a id="af285721a1a58d67cc4e23c156fd54a59" name="af285721a1a58d67cc4e23c156fd54a59"></a>
<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getBBoxDelta</b> () const</td></tr>
<tr class="memdesc:af285721a1a58d67cc4e23c156fd54a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounding box minimum point. <br /></td></tr>
<tr class="separator:af285721a1a58d67cc4e23c156fd54a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2788da92a0ca9fdcf723905fd82f9e34" id="r_a2788da92a0ca9fdcf723905fd82f9e34"><td class="memItemLeft" align="right" valign="top"><a id="a2788da92a0ca9fdcf723905fd82f9e34" name="a2788da92a0ca9fdcf723905fd82f9e34"></a>
<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getAspect</b> () const</td></tr>
<tr class="memdesc:a2788da92a0ca9fdcf723905fd82f9e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the aspect vector. <br /></td></tr>
<tr class="separator:a2788da92a0ca9fdcf723905fd82f9e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d366f3b3e82d0620998895eac64f19" id="r_a15d366f3b3e82d0620998895eac64f19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15d366f3b3e82d0620998895eac64f19">getSample</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> vertex)</td></tr>
<tr class="memdesc:a15d366f3b3e82d0620998895eac64f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample value for vertex.  <br /></td></tr>
<tr class="separator:a15d366f3b3e82d0620998895eac64f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f97308bdd7b451a1389ac717d49300e" id="r_a4f97308bdd7b451a1389ac717d49300e"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>, <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f97308bdd7b451a1389ac717d49300e">cbeginSamples</a> ()</td></tr>
<tr class="memdesc:a4f97308bdd7b451a1389ac717d49300e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a constant forward iterator for the sample data.  <br /></td></tr>
<tr class="separator:a4f97308bdd7b451a1389ac717d49300e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d17db588afce780a743b0bc981c6681" id="r_a8d17db588afce780a743b0bc981c6681"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>, <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d17db588afce780a743b0bc981c6681">cendSamples</a> ()</td></tr>
<tr class="memdesc:a8d17db588afce780a743b0bc981c6681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a constant end iterator for the sample data.  <br /></td></tr>
<tr class="separator:a8d17db588afce780a743b0bc981c6681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell Oriented Coordinate Computation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions compute theoretical values based on a given cell center coordinate, and have nothing to do with sample state.</p>
<p>These functions preform various coordinate computation related to cells. For example, the <a class="el" href="#a84408201cd973bd01514c68954c4991b" title="Compute the top cell coordinates for the tree.">getTopCell()</a> function returns the coordinates that would be used to identify the tree's top cell; however, this function tells us nothing about if that cell exists (as been sampled) in the tree.</p>
<p>In general these routines are optimized for performance, and do not preform any error checking. <br  />
</p>
<ul>
<li>Many functions require a valid cell coordinate (that is a coordinate that could be the center of a cell). For example, if one of these functions is given 0, then erroneous results are likely because 0 represents the coordinate for the corner of a tree which can never the the center of a cell.</li>
<li>When possible, the fewest coordinate components are used. For example <a class="el" href="#add4c07cd23e1d816990b43e95b49f266" title="Compute cell level.">cellLevel()</a> uses just the first coordinate in it's computation. </li>
</ul>
</div></td></tr>
<tr class="memitem:a84408201cd973bd01514c68954c4991b" id="r_a84408201cd973bd01514c68954c4991b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84408201cd973bd01514c68954c4991b">getTopCell</a> () const</td></tr>
<tr class="memdesc:a84408201cd973bd01514c68954c4991b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the top cell coordinates for the tree.  <br /></td></tr>
<tr class="separator:a84408201cd973bd01514c68954c4991b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4c07cd23e1d816990b43e95b49f266" id="r_add4c07cd23e1d816990b43e95b49f266"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add4c07cd23e1d816990b43e95b49f266">cellLevel</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:add4c07cd23e1d816990b43e95b49f266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cell level.  <br /></td></tr>
<tr class="separator:add4c07cd23e1d816990b43e95b49f266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2f1bf21bcbc422924a1290ba6eb37a" id="r_a0c2f1bf21bcbc422924a1290ba6eb37a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c2f1bf21bcbc422924a1290ba6eb37a">cellHalfWidth</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:a0c2f1bf21bcbc422924a1290ba6eb37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cell half width.  <br /></td></tr>
<tr class="separator:a0c2f1bf21bcbc422924a1290ba6eb37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ebbe47919afabc6654a9a9cc7153e4" id="r_ac8ebbe47919afabc6654a9a9cc7153e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8ebbe47919afabc6654a9a9cc7153e4">cellQuarterWidth</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:ac8ebbe47919afabc6654a9a9cc7153e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cell quarter width.  <br /></td></tr>
<tr class="separator:ac8ebbe47919afabc6654a9a9cc7153e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3942f277526f9d7053f8f4eaca89a2c9" id="r_a3942f277526f9d7053f8f4eaca89a2c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3942f277526f9d7053f8f4eaca89a2c9">cellFullWidth</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:a3942f277526f9d7053f8f4eaca89a2c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cell full width.  <br /></td></tr>
<tr class="separator:a3942f277526f9d7053f8f4eaca89a2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9a492991dbe2687fb3583bbdc4c539" id="r_a5e9a492991dbe2687fb3583bbdc4c539"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e9a492991dbe2687fb3583bbdc4c539">cellGetCornerMin</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:a5e9a492991dbe2687fb3583bbdc4c539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell first corner.  <br /></td></tr>
<tr class="separator:a5e9a492991dbe2687fb3583bbdc4c539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ce70034dcfcf3d0cd6f51c6a535834" id="r_af7ce70034dcfcf3d0cd6f51c6a535834"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7ce70034dcfcf3d0cd6f51c6a535834">cellGetCornerMax</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:af7ce70034dcfcf3d0cd6f51c6a535834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell last corner.  <br /></td></tr>
<tr class="separator:af7ce70034dcfcf3d0cd6f51c6a535834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7ba22355636ec7b3a5826aa0161681" id="r_a7c7ba22355636ec7b3a5826aa0161681"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c7ba22355636ec7b3a5826aa0161681">getCorners</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:a7c7ba22355636ec7b3a5826aa0161681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the corners of the given cell.  <br /></td></tr>
<tr class="separator:a7c7ba22355636ec7b3a5826aa0161681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a97c2babab150d8d592e4530be492c" id="r_ae7a97c2babab150d8d592e4530be492c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7a97c2babab150d8d592e4530be492c">getCorners</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell, int index, int direction) const</td></tr>
<tr class="memdesc:ae7a97c2babab150d8d592e4530be492c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the corners of the given cell.  <br /></td></tr>
<tr class="separator:ae7a97c2babab150d8d592e4530be492c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb5b3756c2419b8ab059365f83a4040" id="r_afbb5b3756c2419b8ab059365f83a4040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbb5b3756c2419b8ab059365f83a4040">getNeighbors</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:afbb5b3756c2419b8ab059365f83a4040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of neighbor cells of the specified cell.  <br /></td></tr>
<tr class="separator:afbb5b3756c2419b8ab059365f83a4040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0fee7fe01440e855e8603c126a033c" id="r_a2c0fee7fe01440e855e8603c126a033c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c0fee7fe01440e855e8603c126a033c">getNeighbor</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell, int index, int direction) const</td></tr>
<tr class="memdesc:a2c0fee7fe01440e855e8603c126a033c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the neighbor cell along the given axis in the specified direction.  <br /></td></tr>
<tr class="separator:a2c0fee7fe01440e855e8603c126a033c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cce8829fb7c9aeefa3cbde7022a882c" id="r_a2cce8829fb7c9aeefa3cbde7022a882c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cce8829fb7c9aeefa3cbde7022a882c">getChildren</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:a2cce8829fb7c9aeefa3cbde7022a882c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of child cells of the specified cell If cell can't have children because it is at maximal depth, then an empty vector is returned.  <br /></td></tr>
<tr class="separator:a2cce8829fb7c9aeefa3cbde7022a882c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841c11cd4e4692ce30e1ce2a6567e04e" id="r_a841c11cd4e4692ce30e1ce2a6567e04e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a841c11cd4e4692ce30e1ce2a6567e04e">getChildren</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell, int index, int direction) const</td></tr>
<tr class="memdesc:a841c11cd4e4692ce30e1ce2a6567e04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of child cells of the specified cell An empty vector is returned if no children are possible.  <br /></td></tr>
<tr class="separator:a841c11cd4e4692ce30e1ce2a6567e04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc09fffdce1a5c12000d4d9b7f754ab" id="r_afdc09fffdce1a5c12000d4d9b7f754ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdc09fffdce1a5c12000d4d9b7f754ab">getVertexes</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:afdc09fffdce1a5c12000d4d9b7f754ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the vertexes (corners and center) of the given cell.  <br /></td></tr>
<tr class="separator:afdc09fffdce1a5c12000d4d9b7f754ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low Level Integer Tuple Computation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions encapsulate various coordinate computations.</p>
<p>In general these routines are optimized for performance, and do not preform any error checking. For example it is possible to underflow/overflow with inappropriate values. </p>
</div></td></tr>
<tr class="memitem:a55b17a6d86e381a7b93c40d1b9ad667e" id="r_a55b17a6d86e381a7b93c40d1b9ad667e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55b17a6d86e381a7b93c40d1b9ad667e">getCrd</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> iiCrdTup, int index) const</td></tr>
<tr class="memdesc:a55b17a6d86e381a7b93c40d1b9ad667e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a component from a tuple.  <br /></td></tr>
<tr class="separator:a55b17a6d86e381a7b93c40d1b9ad667e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38132e1b3bdc9de2cccc064d19874b66" id="r_a38132e1b3bdc9de2cccc064d19874b66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38132e1b3bdc9de2cccc064d19874b66">incCrd</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> iiCrdTup, int index, <a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a> value) const</td></tr>
<tr class="memdesc:a38132e1b3bdc9de2cccc064d19874b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incriment a component in a a tuple.  <br /></td></tr>
<tr class="separator:a38132e1b3bdc9de2cccc064d19874b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b038c6b81ff096b78a22b19151080d" id="r_a05b038c6b81ff096b78a22b19151080d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05b038c6b81ff096b78a22b19151080d">decCrd</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> iiCrdTup, int index, <a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a> value) const</td></tr>
<tr class="memdesc:a05b038c6b81ff096b78a22b19151080d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decriment a component in a a tuple.  <br /></td></tr>
<tr class="separator:a05b038c6b81ff096b78a22b19151080d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa15553664535d154ad1e998a3ea03d0" id="r_afa15553664535d154ad1e998a3ea03d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa15553664535d154ad1e998a3ea03d0">decAllCrd</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> iiCrdTup, <a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a> value) const</td></tr>
<tr class="memdesc:afa15553664535d154ad1e998a3ea03d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decriment all components in a a tuple.  <br /></td></tr>
<tr class="separator:afa15553664535d154ad1e998a3ea03d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2025bddbd8b8e365ef1854c934c48ed8" id="r_a2025bddbd8b8e365ef1854c934c48ed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2025bddbd8b8e365ef1854c934c48ed8">incAllCrd</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> iiCrdTup, <a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a> value) const</td></tr>
<tr class="memdesc:a2025bddbd8b8e365ef1854c934c48ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incriment all components in a a tuple.  <br /></td></tr>
<tr class="separator:a2025bddbd8b8e365ef1854c934c48ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b37a4890bbaff06b93d2cfee09ba44" id="r_a54b37a4890bbaff06b93d2cfee09ba44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54b37a4890bbaff06b93d2cfee09ba44">setAllCrd</a> (<a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a> value) const</td></tr>
<tr class="memdesc:a54b37a4890bbaff06b93d2cfee09ba44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all components in a a tuple to a constant.  <br /></td></tr>
<tr class="separator:a54b37a4890bbaff06b93d2cfee09ba44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1ebd3feea16bac6622f8dbbf0fd8ec" id="r_acb1ebd3feea16bac6622f8dbbf0fd8ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb1ebd3feea16bac6622f8dbbf0fd8ec">getTwoCross</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> iiCrdTup, <a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a> delta) const</td></tr>
<tr class="memdesc:acb1ebd3feea16bac6622f8dbbf0fd8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cross product points centered at iiCrdTup and delta away TODO: Should this be private? TODO: If iiCrdTup is close to an corner, then some of the cross product points may be out of range.  <br /></td></tr>
<tr class="separator:acb1ebd3feea16bac6622f8dbbf0fd8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e44be98f354ee2ae4ba5d0c92b79262" id="r_a8e44be98f354ee2ae4ba5d0c92b79262"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e44be98f354ee2ae4ba5d0c92b79262">getTwoCross</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> iiCrdTup, <a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a> delta, int index, int direction) const</td></tr>
<tr class="memdesc:a8e44be98f354ee2ae4ba5d0c92b79262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute directional cross product points centered at iiCrdTup and delta away.  <br /></td></tr>
<tr class="separator:a8e44be98f354ee2ae4ba5d0c92b79262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32593c3ddb30acad46f7f7576788cfc1" id="r_a32593c3ddb30acad46f7f7576788cfc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32593c3ddb30acad46f7f7576788cfc1">getAxisCross</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> iiCrdTup, <a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a> delta) const</td></tr>
<tr class="memdesc:a32593c3ddb30acad46f7f7576788cfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute axis aligned cross points centered at iiCrdTup and delta away TODO: Should this be private? Axis aligned cross points that fall outside of the domain will not be returned.  <br /></td></tr>
<tr class="separator:a32593c3ddb30acad46f7f7576788cfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Easy way to treat rangeT &amp; domainT types as indexable regardless of domDim &amp; rngDim.</div></td></tr>
<tr><td colspan="2"><div class="groupHeader">Packed Integer Tuple &lt;-&gt; Vector of Integer Tuple Conversions</div></td></tr>
<tr class="memitem:a3cf9daed0c604d1bfd3145728f0b5402" id="r_a3cf9daed0c604d1bfd3145728f0b5402"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cf9daed0c604d1bfd3145728f0b5402">vi2iiCrdTup</a> (const <a class="el" href="#a0b8008bf1a2994bb4cd2762b0eed8c74">viCrdTupT</a> &amp;inVecTup) const</td></tr>
<tr class="memdesc:a3cf9daed0c604d1bfd3145728f0b5402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an vector of integer coordinate tuple to an packed integer coordinate tuple.  <br /></td></tr>
<tr class="separator:a3cf9daed0c604d1bfd3145728f0b5402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fccfb6ada76f1106c44aa90cdbf77f" id="r_a11fccfb6ada76f1106c44aa90cdbf77f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a0b8008bf1a2994bb4cd2762b0eed8c74">viCrdTupT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11fccfb6ada76f1106c44aa90cdbf77f">ii2viCrdTup</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> inIntTup) const</td></tr>
<tr class="memdesc:a11fccfb6ada76f1106c44aa90cdbf77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a packed integer coordinate tuple to a vector of integer coordinate tuple Note viCrdTupT is <em>always</em> a vector even when domDim==1.  <br /></td></tr>
<tr class="separator:a11fccfb6ada76f1106c44aa90cdbf77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Integer Tuple to Domain Space Tuple Conversion</div></td></tr>
<tr class="memitem:a14b188f7701f6069bc018f4b93b8b801" id="r_a14b188f7701f6069bc018f4b93b8b801"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14b188f7701f6069bc018f4b93b8b801">iiCrdTup2domain</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> iiCrdTup) const</td></tr>
<tr class="memdesc:a14b188f7701f6069bc018f4b93b8b801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a packed integer coordinate tuple to the coorisponding coordinate in domainT Note this function might return a scalar (float, double, etc...) or a std::vector!  <br /></td></tr>
<tr class="separator:a14b188f7701f6069bc018f4b93b8b801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce3c8dfd86a646cfbf7b62a673f3494" id="r_afce3c8dfd86a646cfbf7b62a673f3494"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#abd496b12394781f40294fb4375a1fee7">rangeVectorT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afce3c8dfd86a646cfbf7b62a673f3494">iiCrdTup2domainVector</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> iiCrdTup) const</td></tr>
<tr class="memdesc:afce3c8dfd86a646cfbf7b62a673f3494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a packed integer coordinate tuple to the coorisponding <em>VECTOR</em> tuple of domRngBaseT Unlike iiCrdTup2domain, this function ALWAYS returns a vector!  <br /></td></tr>
<tr class="separator:afce3c8dfd86a646cfbf7b62a673f3494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Function Sampleing</div></td></tr>
<tr class="memitem:a8145c6893b496f08be1a16d172de8e11" id="r_a8145c6893b496f08be1a16d172de8e11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8145c6893b496f08be1a16d172de8e11">sampleFunction</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell, int depth, std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt; func)</td></tr>
<tr class="memdesc:a8145c6893b496f08be1a16d172de8e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a function uniformly to a given cell depth.  <br /></td></tr>
<tr class="separator:a8145c6893b496f08be1a16d172de8e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b39107cd836f7632c7bb10dfb597d3d" id="r_a7b39107cd836f7632c7bb10dfb597d3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b39107cd836f7632c7bb10dfb597d3d">refineRecursive</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell, int depth, std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt; func)</td></tr>
<tr class="memdesc:a7b39107cd836f7632c7bb10dfb597d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine a cell until refined cells reach specified depth.  <br /></td></tr>
<tr class="separator:a7b39107cd836f7632c7bb10dfb597d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826a4c3c021a3c24e19dcf59a0879356" id="r_a826a4c3c021a3c24e19dcf59a0879356"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a826a4c3c021a3c24e19dcf59a0879356">refineRecursiveCellPred</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell, int depth, std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt; func, std::function&lt; bool(<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>)&gt; pred)</td></tr>
<tr class="memdesc:a826a4c3c021a3c24e19dcf59a0879356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine a cells matching predicate until refined cells reach specified depth.  <br /></td></tr>
<tr class="separator:a826a4c3c021a3c24e19dcf59a0879356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d89ac404d2eb4274a0f7f6d85048149" id="r_a7d89ac404d2eb4274a0f7f6d85048149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d89ac404d2eb4274a0f7f6d85048149">refineRecursiveIfCellVertexIsNaN</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell, int depth, std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt; func)</td></tr>
<tr class="memdesc:a7d89ac404d2eb4274a0f7f6d85048149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine a cells with NaNs until refined cells reach specified depth.  <br /></td></tr>
<tr class="separator:a7d89ac404d2eb4274a0f7f6d85048149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5873f343cf85a70650c92ff6729cd0d" id="r_ad5873f343cf85a70650c92ff6729cd0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5873f343cf85a70650c92ff6729cd0d">refineOnce</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell, std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt; func)</td></tr>
<tr class="memdesc:ad5873f343cf85a70650c92ff6729cd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine a cell.  <br /></td></tr>
<tr class="separator:ad5873f343cf85a70650c92ff6729cd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed46836b46fe14695b1617f2560417e" id="r_a6ed46836b46fe14695b1617f2560417e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ed46836b46fe14695b1617f2560417e">sampleCell</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell, std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt; func)</td></tr>
<tr class="memdesc:a6ed46836b46fe14695b1617f2560417e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a cell.  <br /></td></tr>
<tr class="separator:a6ed46836b46fe14695b1617f2560417e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124c6d1f9738efed192073590660c1dd" id="r_a124c6d1f9738efed192073590660c1dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a124c6d1f9738efed192073590660c1dd">samplePointMaybe</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> iiCrdTup, std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt; func)</td></tr>
<tr class="memdesc:a124c6d1f9738efed192073590660c1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a point if it has not already been sampled.  <br /></td></tr>
<tr class="separator:a124c6d1f9738efed192073590660c1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06636b9cca675fccf7572a610e5bb73c" id="r_a06636b9cca675fccf7572a610e5bb73c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06636b9cca675fccf7572a610e5bb73c">samplePoint</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> iiCrdTup, std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt; func)</td></tr>
<tr class="memdesc:a06636b9cca675fccf7572a610e5bb73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a point.  <br /></td></tr>
<tr class="separator:a06636b9cca675fccf7572a610e5bb73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell Predicates</div></td></tr>
<tr class="memitem:a0ba67bf5417f63e1b2b0f38e7f634757" id="r_a0ba67bf5417f63e1b2b0f38e7f634757"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ba67bf5417f63e1b2b0f38e7f634757">cellGoodCords</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:a0ba67bf5417f63e1b2b0f38e7f634757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if cell coordinates are in range to be a cell center.  <br /></td></tr>
<tr class="separator:a0ba67bf5417f63e1b2b0f38e7f634757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6cc9dd07a67c9f45760773cc98c4a2" id="r_a2d6cc9dd07a67c9f45760773cc98c4a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d6cc9dd07a67c9f45760773cc98c4a2">cellExists</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:a2d6cc9dd07a67c9f45760773cc98c4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell has been sampled.  <br /></td></tr>
<tr class="separator:a2d6cc9dd07a67c9f45760773cc98c4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17f7335fe9debbab9517584e3058551" id="r_ac17f7335fe9debbab9517584e3058551"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac17f7335fe9debbab9517584e3058551">cellGoodSamples</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:ac17f7335fe9debbab9517584e3058551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell has been sampled.  <br /></td></tr>
<tr class="separator:ac17f7335fe9debbab9517584e3058551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af4a0e0ab3a58a603e8a845d9916c8c" id="r_a5af4a0e0ab3a58a603e8a845d9916c8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af4a0e0ab3a58a603e8a845d9916c8c">cellVertexIsNaN</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell)</td></tr>
<tr class="memdesc:a5af4a0e0ab3a58a603e8a845d9916c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell has a vertex with a NaN value for a sample.  <br /></td></tr>
<tr class="separator:a5af4a0e0ab3a58a603e8a845d9916c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f992530d253d3a40bf5fc3fa564b865" id="r_a3f992530d253d3a40bf5fc3fa564b865"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f992530d253d3a40bf5fc3fa564b865">cellCornerIsNaN</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell)</td></tr>
<tr class="memdesc:a3f992530d253d3a40bf5fc3fa564b865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell has an corner with a NaN value for a sample.  <br /></td></tr>
<tr class="separator:a3f992530d253d3a40bf5fc3fa564b865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27673b6df6d80eb5751aacf41b356bc" id="r_af27673b6df6d80eb5751aacf41b356bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af27673b6df6d80eb5751aacf41b356bc">cellHasChild</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:af27673b6df6d80eb5751aacf41b356bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell has children.  <br /></td></tr>
<tr class="separator:af27673b6df6d80eb5751aacf41b356bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861ff35c0766a109fbb7a522c657b438" id="r_a861ff35c0766a109fbb7a522c657b438"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a861ff35c0766a109fbb7a522c657b438">cellHasNoChild</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:a861ff35c0766a109fbb7a522c657b438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell has no children.  <br /></td></tr>
<tr class="separator:a861ff35c0766a109fbb7a522c657b438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824b99963b663eb75458d5caa47a125a" id="r_a824b99963b663eb75458d5caa47a125a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a824b99963b663eb75458d5caa47a125a">cellCanHaveChildren</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:a824b99963b663eb75458d5caa47a125a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell can have children (it not of minimal size)  <br /></td></tr>
<tr class="separator:a824b99963b663eb75458d5caa47a125a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cb59a06961f0b0b110f73cba1a45aa" id="r_af6cb59a06961f0b0b110f73cba1a45aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6cb59a06961f0b0b110f73cba1a45aa">cellHasNeighbor</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell, int index, int direction)</td></tr>
<tr class="memdesc:af6cb59a06961f0b0b110f73cba1a45aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the specified neighbor cell exixts (is smapled).  <br /></td></tr>
<tr class="separator:af6cb59a06961f0b0b110f73cba1a45aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2635985c521d73f58d3f728217294f6" id="r_ad2635985c521d73f58d3f728217294f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2635985c521d73f58d3f728217294f6">cellCrossSDF</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell, std::function&lt; domRngBaseT(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt; signFunc)</td></tr>
<tr class="memdesc:ad2635985c521d73f58d3f728217294f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell crosses a signed distance function boundry.  <br /></td></tr>
<tr class="separator:ad2635985c521d73f58d3f728217294f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vertex Predicates</div></td></tr>
<tr class="memitem:acad249449b3c4a4288171c8226df0d72" id="r_acad249449b3c4a4288171c8226df0d72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acad249449b3c4a4288171c8226df0d72">vertexIsNaN</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> vertex)</td></tr>
<tr class="memdesc:acad249449b3c4a4288171c8226df0d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a vertex is NaN or, when it is a vector, if it contains a NaN element.  <br /></td></tr>
<tr class="separator:acad249449b3c4a4288171c8226df0d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee120c4451966cd9d7afa29fcd1b6c01" id="r_aee120c4451966cd9d7afa29fcd1b6c01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee120c4451966cd9d7afa29fcd1b6c01">vertexExists</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> vertex) const</td></tr>
<tr class="memdesc:aee120c4451966cd9d7afa29fcd1b6c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point has been sampled.  <br /></td></tr>
<tr class="separator:aee120c4451966cd9d7afa29fcd1b6c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extract Cells</div></td></tr>
<tr class="memitem:a750971db4a498c971500b18606c1611b" id="r_a750971db4a498c971500b18606c1611b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a750971db4a498c971500b18606c1611b">getLeafCells</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:a750971db4a498c971500b18606c1611b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a list of all leaf cells starting from the given cell.  <br /></td></tr>
<tr class="separator:a750971db4a498c971500b18606c1611b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d16c00c5a6fc87b9ba59c58ddfe5024" id="r_a9d16c00c5a6fc87b9ba59c58ddfe5024"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d16c00c5a6fc87b9ba59c58ddfe5024">getLeafCells</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell, int index, int direction) const</td></tr>
<tr class="memdesc:a9d16c00c5a6fc87b9ba59c58ddfe5024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a list of all leaf cells starting from the given cell.  <br /></td></tr>
<tr class="separator:a9d16c00c5a6fc87b9ba59c58ddfe5024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52720571aaa25affab527644ef16f59f" id="r_a52720571aaa25affab527644ef16f59f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52720571aaa25affab527644ef16f59f">countLeafCells</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell) const</td></tr>
<tr class="memdesc:a52720571aaa25affab527644ef16f59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of leaf cells starting from the given cell.  <br /></td></tr>
<tr class="separator:a52720571aaa25affab527644ef16f59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db8f2c9c69e6e1fcd1a24d91b2925fd" id="r_a6db8f2c9c69e6e1fcd1a24d91b2925fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6db8f2c9c69e6e1fcd1a24d91b2925fd">getExistingNeighbor</a> (<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> cell, int index, int direction) const</td></tr>
<tr class="memdesc:a6db8f2c9c69e6e1fcd1a24d91b2925fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of sampled neighbors to the given cell.  <br /></td></tr>
<tr class="separator:a6db8f2c9c69e6e1fcd1a24d91b2925fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a98ab7e24a7758f09e63ede4e6f4cabba" id="r_a98ab7e24a7758f09e63ede4e6f4cabba"><td class="memItemLeft" align="right" valign="top"><a id="a98ab7e24a7758f09e63ede4e6f4cabba" name="a98ab7e24a7758f09e63ede4e6f4cabba"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>domainDimension</b> = domDim</td></tr>
<tr class="memdesc:a98ab7e24a7758f09e63ede4e6f4cabba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the template parameter domDim. <br /></td></tr>
<tr class="separator:a98ab7e24a7758f09e63ede4e6f4cabba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe95de3d8314db606bb5a1ef695385d4" id="r_abe95de3d8314db606bb5a1ef695385d4"><td class="memItemLeft" align="right" valign="top"><a id="abe95de3d8314db606bb5a1ef695385d4" name="abe95de3d8314db606bb5a1ef695385d4"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>rangeDimension</b> = rngDim</td></tr>
<tr class="memdesc:abe95de3d8314db606bb5a1ef695385d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the template parameter rngDim. <br /></td></tr>
<tr class="separator:abe95de3d8314db606bb5a1ef695385d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbcd1d144b032caea90a0650583a114" id="r_adfbcd1d144b032caea90a0650583a114"><td class="memItemLeft" align="right" valign="top"><a id="adfbcd1d144b032caea90a0650583a114" name="adfbcd1d144b032caea90a0650583a114"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>maximumDepth</b> = maxDepth</td></tr>
<tr class="memdesc:adfbcd1d144b032caea90a0650583a114"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the template parameter maxDepth. <br /></td></tr>
<tr class="separator:adfbcd1d144b032caea90a0650583a114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebfd535f5d0f8196dcd0c3c07249245" id="r_aeebfd535f5d0f8196dcd0c3c07249245"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeebfd535f5d0f8196dcd0c3c07249245">iCrdCmpBits</a> = maxDepth+1</td></tr>
<tr class="memdesc:aeebfd535f5d0f8196dcd0c3c07249245"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bits used by a single component of an integer coordinate tuple.  <br /></td></tr>
<tr class="separator:aeebfd535f5d0f8196dcd0c3c07249245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb4f3cb8b2902b5d36e870e9cc56fa5" id="r_accb4f3cb8b2902b5d36e870e9cc56fa5"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accb4f3cb8b2902b5d36e870e9cc56fa5">iiCrdTupBits</a> = <a class="el" href="#aeebfd535f5d0f8196dcd0c3c07249245">iCrdCmpBits</a> * domDim</td></tr>
<tr class="memdesc:accb4f3cb8b2902b5d36e870e9cc56fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bits used by an entire integer coordinate tuple.  <br /></td></tr>
<tr class="separator:accb4f3cb8b2902b5d36e870e9cc56fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff2343ded8c510ccd76f84ca3ca7050" id="r_a9ff2343ded8c510ccd76f84ca3ca7050"><td class="memItemLeft" align="right" valign="top"><a id="a9ff2343ded8c510ccd76f84ca3ca7050" name="a9ff2343ded8c510ccd76f84ca3ca7050"></a>
static constexpr <a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iCrdCmpMax</b> = (static_cast&lt;<a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a>&gt;(1) &lt;&lt; maxDepth)</td></tr>
<tr class="memdesc:a9ff2343ded8c510ccd76f84ca3ca7050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowd for a iCrdCmpT. <br /></td></tr>
<tr class="separator:a9ff2343ded8c510ccd76f84ca3ca7050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa543177174ac6bade4e49ceec5ff0dea" id="r_aa543177174ac6bade4e49ceec5ff0dea"><td class="memItemLeft" align="right" valign="top"><a id="aa543177174ac6bade4e49ceec5ff0dea" name="aa543177174ac6bade4e49ceec5ff0dea"></a>
static constexpr <a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iCrdCmpCtr</b> = (static_cast&lt;<a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a>&gt;(1) &lt;&lt; (maxDepth-1))</td></tr>
<tr class="memdesc:aa543177174ac6bade4e49ceec5ff0dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Center value for a iCrdCmpT. <br /></td></tr>
<tr class="separator:aa543177174ac6bade4e49ceec5ff0dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbacd39c5f224a23501d237453dcd6b7" id="r_abbacd39c5f224a23501d237453dcd6b7"><td class="memItemLeft" align="right" valign="top"><a id="abbacd39c5f224a23501d237453dcd6b7" name="abbacd39c5f224a23501d237453dcd6b7"></a>
static constexpr <a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a>&#160;</td><td class="memItemRight" valign="bottom"><b>iCrdCmpMin</b> = 0</td></tr>
<tr class="memdesc:abbacd39c5f224a23501d237453dcd6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum allowd for a iCrdCmpT. <br /></td></tr>
<tr class="separator:abbacd39c5f224a23501d237453dcd6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int maxDepth, class domRngBaseT, int domDim, int rngDim&gt;<br />
requires ((maxDepth&gt;0) &amp;&amp; (domDim&gt;0) &amp;&amp; (rngDim&gt;0) &amp;&amp; (domDim*maxDepth&lt;=CHAR_BIT*sizeof(uint64_t)) &amp;&amp; (std::is_floating_point&lt;domRngBaseT&gt;::value))<br />
class mjr::MRPTree&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;</div><p>Template Class used to house an <a class="el" href="classmjr_1_1_m_r_p_tree.html" title="Template Class used to house an MRPTree.">MRPTree</a>. </p>
<p>For a function f:R^2-&gt;R^3, we might use:</p><ul>
<li>domRngBaseT = double</li>
<li>domDim = 2</li>
<li>rngDim = 3</li>
<li>maxDepth = 7 or 15</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">maxDepth</td><td>The maximum depth of the tree. Most efficient operation when maxDepth=pow(2, n)-1 for some n. </td></tr>
    <tr><td class="paramname">domRngBaseT</td><td>The base domain for both doma &amp; range. </td></tr>
    <tr><td class="paramname">domDim</td><td>Domain dimension. </td></tr>
    <tr><td class="paramname">rngDim</td><td>Index for the Blue channel. -1 indicates no Red channel. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af7dd7a32cbad34b0e20a31cd7a1aec52" name="af7dd7a32cbad34b0e20a31cd7a1aec52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7dd7a32cbad34b0e20a31cd7a1aec52">&#9670;&#160;</a></span>domainT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::conditional&lt;std::cmp_equal(domDim,1),domRngBaseT,std::vector&lt;domRngBaseT&gt;&gt;::type <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::domainT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type used to hold values in the domain space of our tree. </p>
<p><br  />
</p><ul>
<li>When domDim==1, this will be domRngBaseT</li>
<li>When domDim!=1, this will be a vector of domRngBaseT See also rangeT. </li>
</ul>

</div>
</div>
<a id="ae9276573dd0bb3afc7b20dbf9a781d45" name="ae9276573dd0bb3afc7b20dbf9a781d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9276573dd0bb3afc7b20dbf9a781d45">&#9670;&#160;</a></span>iCrdCmpT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef iCrdCmpIntT <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::iCrdCmpT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An unsigned integer type large enough to hold a single component of an integer coordinate tuple. </p>
<p><br  />
 This will be the smallest unsigned integer type with bitsize equal to a power of two and larger than maxDepth </p>

</div>
</div>
<a id="a8d7b92c9825ca9127c2763b8356a8042" name="a8d7b92c9825ca9127c2763b8356a8042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7b92c9825ca9127c2763b8356a8042">&#9670;&#160;</a></span>listCrdTup</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>&gt; <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::listCrdTup</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A std::vector used to pass lists of iiCrdTupT types around. </p>
<p><br  />
 </p>

</div>
</div>
<a id="abbd5d4c5318f6fedf507ea075d22bcf2" name="abbd5d4c5318f6fedf507ea075d22bcf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd5d4c5318f6fedf507ea075d22bcf2">&#9670;&#160;</a></span>rangeT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::conditional&lt;std::cmp_equal(rngDim,1),domRngBaseT,std::vector&lt;domRngBaseT&gt;&gt;::type <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::rangeT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A type used to hold values in the range space of our tree. </p>
<p><br  />
</p><ul>
<li>When rngDim==1, this will be rngRngBaseT</li>
<li>When rngDim!=1, this will be a vector of rngRngBaseT See also domainT. </li>
</ul>

</div>
</div>
<a id="a0b8008bf1a2994bb4cd2762b0eed8c74" name="a0b8008bf1a2994bb4cd2762b0eed8c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8008bf1a2994bb4cd2762b0eed8c74">&#9670;&#160;</a></span>viCrdTupT</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a>&gt; <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::viCrdTupT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector holding integer coordinate components &ndash; i.e. </p>
<p>a std::vector version of iiCrdTupT. <br  />
 </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7011eb700b6135191e253b4d2ef2277e" name="a7011eb700b6135191e253b4d2ef2277e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7011eb700b6135191e253b4d2ef2277e">&#9670;&#160;</a></span>MRPTree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::MRPTree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set real coordinate &amp; aspect ratio to defaults. </p>
<p>see: <a class="el" href="#a0709df9d096eccbebb6b4472820205e1" title="Set the bounding box to the default: -1 for all minimum components and +1 for all maximum components.">setBBoxDefault()</a> &amp; <a class="el" href="#ad2c8c7d6d1cc1783b743a55af2edd1e2" title="Set the aspect ratio to the default: 1.0 for all components.">setAspectDefault()</a>. </p>

</div>
</div>
<a id="a32297f16fbf8ef677134ad41e74b9f45" name="a32297f16fbf8ef677134ad41e74b9f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32297f16fbf8ef677134ad41e74b9f45">&#9670;&#160;</a></span>MRPTree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::MRPTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a></td>          <td class="paramname"><span class="paramname"><em>newBBoxMin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a></td>          <td class="paramname"><span class="paramname"><em>newBBoxMax</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set real coordinate as specified &amp; aspect ratio to default. </p>
<p>see: <a class="el" href="#ad2c8c7d6d1cc1783b743a55af2edd1e2" title="Set the aspect ratio to the default: 1.0 for all components.">setAspectDefault()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newBBoxMin</td><td>Value to use for bounding box minimum point </td></tr>
    <tr><td class="paramname">newBBoxMax</td><td>Value to use for bounding box maximum point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4f97308bdd7b451a1389ac717d49300e" name="a4f97308bdd7b451a1389ac717d49300e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f97308bdd7b451a1389ac717d49300e">&#9670;&#160;</a></span>cbeginSamples()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; <a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>, <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a> &gt;::const_iterator <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cbeginSamples </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a constant forward iterator for the sample data. </p>
<p>Sample data is stored as a pair with the first element being the packed integer domain coordinates and the second being the sampled data. </p>

</div>
</div>
<a id="a824b99963b663eb75458d5caa47a125a" name="a824b99963b663eb75458d5caa47a125a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824b99963b663eb75458d5caa47a125a">&#9670;&#160;</a></span>cellCanHaveChildren()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellCanHaveChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell can have children (it not of minimal size) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f992530d253d3a40bf5fc3fa564b865" name="a3f992530d253d3a40bf5fc3fa564b865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f992530d253d3a40bf5fc3fa564b865">&#9670;&#160;</a></span>cellCornerIsNaN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellCornerIsNaN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell has an corner with a NaN value for a sample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2635985c521d73f58d3f728217294f6" name="ad2635985c521d73f58d3f728217294f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2635985c521d73f58d3f728217294f6">&#9670;&#160;</a></span>cellCrossSDF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellCrossSDF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; domRngBaseT(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>signFunc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell crosses a signed distance function boundry. </p>
<dl class="section warning"><dt>Warning</dt><dd>Incorrect result if ALL vertexes of the cell are zero. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input Cell </td></tr>
    <tr><td class="paramname">signFunc</td><td>Signed distance function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the cell crosses the signed distance function. </dd></dl>

</div>
</div>
<a id="a2d6cc9dd07a67c9f45760773cc98c4a2" name="a2d6cc9dd07a67c9f45760773cc98c4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6cc9dd07a67c9f45760773cc98c4a2">&#9670;&#160;</a></span>cellExists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell has been sampled. </p>
<dl class="section warning"><dt>Warning</dt><dd>Simply checks that cell has been sampled &ndash; identical to <a class="el" href="#aee120c4451966cd9d7afa29fcd1b6c01" title="Point has been sampled.">vertexExists()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3942f277526f9d7053f8f4eaca89a2c9" name="a3942f277526f9d7053f8f4eaca89a2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3942f277526f9d7053f8f4eaca89a2c9">&#9670;&#160;</a></span>cellFullWidth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellFullWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute cell full width. </p>
<dl class="section warning"><dt>Warning</dt><dd>No error checking &ndash; cell must be a valid center coordinate. See: cellCordsGood() </dd>
<dd>
Only uses the last iCrdCmp in the cell to compute value. Thus inconsistant components will not be detected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Full width of the given cell. </dd></dl>

</div>
</div>
<a id="af7ce70034dcfcf3d0cd6f51c6a535834" name="af7ce70034dcfcf3d0cd6f51c6a535834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ce70034dcfcf3d0cd6f51c6a535834">&#9670;&#160;</a></span>cellGetCornerMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellGetCornerMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cell last corner. </p>
<dl class="section warning"><dt>Warning</dt><dd>No error checking &ndash; cell must be a valid center coordinate. See: cellCordsGood() </dd>
<dd>
Only uses the last iCrdCmp in the cell to compute value. Thus inconsistant components will not be detected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last corner of given cell </dd></dl>

</div>
</div>
<a id="a5e9a492991dbe2687fb3583bbdc4c539" name="a5e9a492991dbe2687fb3583bbdc4c539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9a492991dbe2687fb3583bbdc4c539">&#9670;&#160;</a></span>cellGetCornerMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellGetCornerMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cell first corner. </p>
<dl class="section warning"><dt>Warning</dt><dd>No error checking &ndash; cell must be a valid center coordinate. See: cellCordsGood() </dd>
<dd>
Only uses the last iCrdCmp in the cell to compute value. Thus inconsistant components will not be detected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>First corner of given cell </dd></dl>

</div>
</div>
<a id="a0ba67bf5417f63e1b2b0f38e7f634757" name="a0ba67bf5417f63e1b2b0f38e7f634757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba67bf5417f63e1b2b0f38e7f634757">&#9670;&#160;</a></span>cellGoodCords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellGoodCords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if cell coordinates are in range to be a cell center. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if cell is in bounds, false otherwise </dd></dl>

</div>
</div>
<a id="ac17f7335fe9debbab9517584e3058551" name="ac17f7335fe9debbab9517584e3058551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17f7335fe9debbab9517584e3058551">&#9670;&#160;</a></span>cellGoodSamples()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellGoodSamples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell has been sampled. </p>
<dl class="section warning"><dt>Warning</dt><dd>Simply checks that cell has been sampled &ndash; identical to <a class="el" href="#aee120c4451966cd9d7afa29fcd1b6c01" title="Point has been sampled.">vertexExists()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c2f1bf21bcbc422924a1290ba6eb37a" name="a0c2f1bf21bcbc422924a1290ba6eb37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2f1bf21bcbc422924a1290ba6eb37a">&#9670;&#160;</a></span>cellHalfWidth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellHalfWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute cell half width. </p>
<dl class="section warning"><dt>Warning</dt><dd>No error checking &ndash; cell must be a valid center coordinate. See: cellCordsGood() </dd>
<dd>
Only uses the last iCrdCmp in the cell to compute value. Thus inconsistant components will not be detected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Half width of the given cell. </dd></dl>

</div>
</div>
<a id="af27673b6df6d80eb5751aacf41b356bc" name="af27673b6df6d80eb5751aacf41b356bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27673b6df6d80eb5751aacf41b356bc">&#9670;&#160;</a></span>cellHasChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellHasChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell has children. </p>
<dl class="section warning"><dt>Warning</dt><dd>Assumes the tree is well formed, and only checks that the "lower left" child's center been sampled! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6cb59a06961f0b0b110f73cba1a45aa" name="af6cb59a06961f0b0b110f73cba1a45aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cb59a06961f0b0b110f73cba1a45aa">&#9670;&#160;</a></span>cellHasNeighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellHasNeighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the specified neighbor cell exixts (is smapled). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the axis. Must be in [0, domDim-1]. No error checking. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction on the given index. Must be 1 or -1. No error checking. </td></tr>
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a861ff35c0766a109fbb7a522c657b438" name="a861ff35c0766a109fbb7a522c657b438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861ff35c0766a109fbb7a522c657b438">&#9670;&#160;</a></span>cellHasNoChild()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellHasNoChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell has no children. </p>
<dl class="section warning"><dt>Warning</dt><dd>Assumes the tree is well formed, and only checks that the "lower left" child's center been sampled! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add4c07cd23e1d816990b43e95b49f266" name="add4c07cd23e1d816990b43e95b49f266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4c07cd23e1d816990b43e95b49f266">&#9670;&#160;</a></span>cellLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute cell level. </p>
<dl class="section warning"><dt>Warning</dt><dd>Cell must be a valid center coordinate. See: cellCordsGood() </dd>
<dd>
Only uses the last iCrdCmp in the cell to compute value. Thus inconsistant components will not be detected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The level of the given cell. </dd></dl>

</div>
</div>
<a id="ac8ebbe47919afabc6654a9a9cc7153e4" name="ac8ebbe47919afabc6654a9a9cc7153e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ebbe47919afabc6654a9a9cc7153e4">&#9670;&#160;</a></span>cellQuarterWidth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellQuarterWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute cell quarter width. </p>
<dl class="section warning"><dt>Warning</dt><dd>No error checking &ndash; cell must be a valid center coordinate. See: cellCordsGood() </dd>
<dd>
Only uses the last iCrdCmp in the cell to compute value. Thus inconsistant components will not be detected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Quarter width of the given cell. </dd></dl>

</div>
</div>
<a id="a5af4a0e0ab3a58a603e8a845d9916c8c" name="a5af4a0e0ab3a58a603e8a845d9916c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af4a0e0ab3a58a603e8a845d9916c8c">&#9670;&#160;</a></span>cellVertexIsNaN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cellVertexIsNaN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell has a vertex with a NaN value for a sample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d17db588afce780a743b0bc981c6681" name="a8d17db588afce780a743b0bc981c6681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d17db588afce780a743b0bc981c6681">&#9670;&#160;</a></span>cendSamples()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; <a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>, <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a> &gt;::const_iterator <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::cendSamples </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a constant end iterator for the sample data. </p>
<p>see: <a class="el" href="#a4f97308bdd7b451a1389ac717d49300e" title="Provide a constant forward iterator for the sample data.">cbeginSamples()</a>. </p>

</div>
</div>
<a id="a52720571aaa25affab527644ef16f59f" name="a52720571aaa25affab527644ef16f59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52720571aaa25affab527644ef16f59f">&#9670;&#160;</a></span>countLeafCells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::countLeafCells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of leaf cells starting from the given cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Starting cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa15553664535d154ad1e998a3ea03d0" name="afa15553664535d154ad1e998a3ea03d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa15553664535d154ad1e998a3ea03d0">&#9670;&#160;</a></span>decAllCrd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::decAllCrd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>iiCrdTup</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decriment all components in a a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iiCrdTup</td><td>The input tuple </td></tr>
    <tr><td class="paramname">value</td><td>Amout by which to decrement each component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New tuple with decrimented components </dd></dl>

</div>
</div>
<a id="a05b038c6b81ff096b78a22b19151080d" name="a05b038c6b81ff096b78a22b19151080d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b038c6b81ff096b78a22b19151080d">&#9670;&#160;</a></span>decCrd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::decCrd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>iiCrdTup</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decriment a component in a a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iiCrdTup</td><td>The input tuple </td></tr>
    <tr><td class="paramname">index</td><td>Which component to incriment </td></tr>
    <tr><td class="paramname">value</td><td>Amout by which to decrement the component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New tuple with the specified component decrimented </dd></dl>

</div>
</div>
<a id="a32593c3ddb30acad46f7f7576788cfc1" name="a32593c3ddb30acad46f7f7576788cfc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32593c3ddb30acad46f7f7576788cfc1">&#9670;&#160;</a></span>getAxisCross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getAxisCross </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>iiCrdTup</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a></td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute axis aligned cross points centered at iiCrdTup and delta away TODO: Should this be private? Axis aligned cross points that fall outside of the domain will not be returned. </p>
<p>For example, if iiCrdTup=0, then we get no points to the left. Examples:</p><ul>
<li>domDom==1 =&gt; {iiCrdTup-delta, iiCrdTup+delta}</li>
<li>domDom==2 =&gt; {iiCrdTup+[0, -delta], iiCrdTup+[0, +delta], iiCrdTup+[-delta, 0], iiCrdTup+[+delta, 0]}</li>
<li>domDom==3 =&gt; {iiCrdTup+[0, 0, -delta], iiCrdTup+[0, 0, +delta], iiCrdTup+[0, -delta, 0], iiCrdTup+[0, +delta, 0], iiCrdTup+[-delta, 0, 0], iiCrdTup+[+delta, 0, 0]} <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iiCrdTup</td><td>Center coordinates for the cross </td></tr>
    <tr><td class="paramname">delta</td><td>The Distance for the cross points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last of cross product points </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a2cce8829fb7c9aeefa3cbde7022a882c" name="a2cce8829fb7c9aeefa3cbde7022a882c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cce8829fb7c9aeefa3cbde7022a882c">&#9670;&#160;</a></span>getChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of child cells of the specified cell If cell can't have children because it is at maximal depth, then an empty vector is returned. </p>
<dl class="section warning"><dt>Warning</dt><dd>This isn't a check for existing, sampled children &ndash; it simply returns the coordinates of potential children. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a841c11cd4e4692ce30e1ce2a6567e04e" name="a841c11cd4e4692ce30e1ce2a6567e04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a841c11cd4e4692ce30e1ce2a6567e04e">&#9670;&#160;</a></span>getChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of child cells of the specified cell An empty vector is returned if no children are possible. </p>
<dl class="section warning"><dt>Warning</dt><dd>This isn't a check for existing, sampled children &ndash; it simply returns the coordinates of potential children. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
    <tr><td class="paramname">index</td><td>The index of the axis. Must be in [0, domDim-1]. No error checking. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction on the given index. Must be 1 or -1. No error checking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c7ba22355636ec7b3a5826aa0161681" name="a7c7ba22355636ec7b3a5826aa0161681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7ba22355636ec7b3a5826aa0161681">&#9670;&#160;</a></span>getCorners() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getCorners </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of the corners of the given cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7a97c2babab150d8d592e4530be492c" name="ae7a97c2babab150d8d592e4530be492c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a97c2babab150d8d592e4530be492c">&#9670;&#160;</a></span>getCorners() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getCorners </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of the corners of the given cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
    <tr><td class="paramname">index</td><td>The index of the axis. Must be in [0, domDim-1]. No error checking. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction on the given index. Must be 1 or -1. No error checking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55b17a6d86e381a7b93c40d1b9ad667e" name="a55b17a6d86e381a7b93c40d1b9ad667e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b17a6d86e381a7b93c40d1b9ad667e">&#9670;&#160;</a></span>getCrd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getCrd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>iiCrdTup</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a component from a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iiCrdTup</td><td>The input tuple </td></tr>
    <tr><td class="paramname">index</td><td>Which component to extract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The component at index position </dd></dl>

</div>
</div>
<a id="a6db8f2c9c69e6e1fcd1a24d91b2925fd" name="a6db8f2c9c69e6e1fcd1a24d91b2925fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db8f2c9c69e6e1fcd1a24d91b2925fd">&#9670;&#160;</a></span>getExistingNeighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getExistingNeighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of sampled neighbors to the given cell. </p>
<dl class="section warning"><dt>Warning</dt><dd>Unlike <a class="el" href="#a2c0fee7fe01440e855e8603c126a033c" title="Return the neighbor cell along the given axis in the specified direction.">getNeighbor()</a>, this member returns a <em>list</em> of <em>existing</em> (sampled) cell centers. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell. Must be a valid cell. &ndash; no error checking. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the axis. Must be in [0, domDim-1]. No error checking. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction on the given index. Must be 1 or -1. No error checking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br  />
 </dd></dl>

</div>
</div>
<a id="a750971db4a498c971500b18606c1611b" name="a750971db4a498c971500b18606c1611b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750971db4a498c971500b18606c1611b">&#9670;&#160;</a></span>getLeafCells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getLeafCells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a list of all leaf cells starting from the given cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Starting cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d16c00c5a6fc87b9ba59c58ddfe5024" name="a9d16c00c5a6fc87b9ba59c58ddfe5024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d16c00c5a6fc87b9ba59c58ddfe5024">&#9670;&#160;</a></span>getLeafCells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getLeafCells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a list of all leaf cells starting from the given cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell. Must be a valid cell. &ndash; no error checking. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the axis. Must be in [0, domDim-1]. No error checking. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction on the given index. Must be 1 or -1. No error checking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c0fee7fe01440e855e8603c126a033c" name="a2c0fee7fe01440e855e8603c126a033c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0fee7fe01440e855e8603c126a033c">&#9670;&#160;</a></span>getNeighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getNeighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the neighbor cell along the given axis in the specified direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
    <tr><td class="paramname">index</td><td>The index of the axis. Must be in [0, domDim-1]. No error checking. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction on the given index. Must be 1 or -1. No error checking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A neighbor cell coordinate or 0 if no neighbor exists. Note 0 is a valid coordinate, but not the center of any cell. </dd></dl>

</div>
</div>
<a id="afbb5b3756c2419b8ab059365f83a4040" name="afbb5b3756c2419b8ab059365f83a4040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbb5b3756c2419b8ab059365f83a4040">&#9670;&#160;</a></span>getNeighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getNeighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of neighbor cells of the specified cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15d366f3b3e82d0620998895eac64f19" name="a15d366f3b3e82d0620998895eac64f19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15d366f3b3e82d0620998895eac64f19">&#9670;&#160;</a></span>getSample()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getSample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>vertex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sample value for vertex. </p>
<dl class="section warning"><dt>Warning</dt><dd>Should only be used when the vertex has been sampled! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>Input vertex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84408201cd973bd01514c68954c4991b" name="a84408201cd973bd01514c68954c4991b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84408201cd973bd01514c68954c4991b">&#9670;&#160;</a></span>getTopCell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getTopCell </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the top cell coordinates for the tree. </p>
<dl class="section return"><dt>Returns</dt><dd>Top cell coordinate for the tree. </dd></dl>

</div>
</div>
<a id="acb1ebd3feea16bac6622f8dbbf0fd8ec" name="acb1ebd3feea16bac6622f8dbbf0fd8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1ebd3feea16bac6622f8dbbf0fd8ec">&#9670;&#160;</a></span>getTwoCross() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getTwoCross </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>iiCrdTup</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a></td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute cross product points centered at iiCrdTup and delta away TODO: Should this be private? TODO: If iiCrdTup is close to an corner, then some of the cross product points may be out of range. </p>
<p>Add a check for this. Error out or just don't push? Examples:</p><ul>
<li>domDom==1 =&gt; {iiCrdTup-delta, iiCrdTup+delta}</li>
<li>domDom==2 =&gt; {iiCrdTup+[-delta, -delta], iiCrdTup+[-delta, +delta], iiCrdTup+[+delta, -delta], iiCrdTup+[+delta, +delta]}</li>
<li>domDom==3 =&gt; {iiCrdTup+[-delta, -delta, -delta], ..., iiCrdTup+[+delta, +delta, +delta]} &ndash; this list will have 8 points <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iiCrdTup</td><td>Center coordinates for the cross product points </td></tr>
    <tr><td class="paramname">delta</td><td>The Distance for the cross product points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last of cross product points </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a8e44be98f354ee2ae4ba5d0c92b79262" name="a8e44be98f354ee2ae4ba5d0c92b79262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e44be98f354ee2ae4ba5d0c92b79262">&#9670;&#160;</a></span>getTwoCross() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getTwoCross </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>iiCrdTup</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a></td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute directional cross product points centered at iiCrdTup and delta away. </p>
<dl class="section warning"><dt>Warning</dt><dd>If iiCrdTup is close to an corner, then some of the cross product points may be out of range! Examples:<ul>
<li>domDom==1, index==0, direction==-1 =&gt; {iiCrdTup-delta}</li>
<li>domDom==1, index==0, direction== 1 =&gt; {iiCrdTup+delta}</li>
<li>domDom==2, index==0, direction==-1 =&gt; {iiCrdTup+[-delta, -delta], iiCrdTup+[-delta, +delta ]}</li>
<li>domDom==2, index==0, direction== 1 =&gt; { iiCrdTup+[+delta, -delta], iiCrdTup+[+delta, +delta]}</li>
<li>domDom==2, index==1, direction==-1 =&gt; {iiCrdTup+[-delta, -delta], iiCrdTup+[+delta, -delta] ]}</li>
<li>domDom==2, index==1, direction== 1 =&gt; { iiCrdTup+[-delta, +delta], iiCrdTup+[+delta, +delta]} </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iiCrdTup</td><td>Center coordinates for the cross product points </td></tr>
    <tr><td class="paramname">delta</td><td>The Distance for the cross product points. </td></tr>
    <tr><td class="paramname">index</td><td>The index to hold constant. Must be in [0, domDom-1]. No error checking. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction on the given index. Must be 1 or -1. No error checking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last of cross product points </dd></dl>

</div>
</div>
<a id="afdc09fffdce1a5c12000d4d9b7f754ab" name="afdc09fffdce1a5c12000d4d9b7f754ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc09fffdce1a5c12000d4d9b7f754ab">&#9670;&#160;</a></span>getVertexes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a8d7b92c9825ca9127c2763b8356a8042">listCrdTup</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::getVertexes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of the vertexes (corners and center) of the given cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11fccfb6ada76f1106c44aa90cdbf77f" name="a11fccfb6ada76f1106c44aa90cdbf77f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fccfb6ada76f1106c44aa90cdbf77f">&#9670;&#160;</a></span>ii2viCrdTup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a0b8008bf1a2994bb4cd2762b0eed8c74">viCrdTupT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::ii2viCrdTup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>inIntTup</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a packed integer coordinate tuple to a vector of integer coordinate tuple Note viCrdTupT is <em>always</em> a vector even when domDim==1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inIntTup</td><td>Packed integer coordinate tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New vector of integer coordinate tuple </dd></dl>

</div>
</div>
<a id="a14b188f7701f6069bc018f4b93b8b801" name="a14b188f7701f6069bc018f4b93b8b801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b188f7701f6069bc018f4b93b8b801">&#9670;&#160;</a></span>iiCrdTup2domain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::iiCrdTup2domain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>iiCrdTup</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a packed integer coordinate tuple to the coorisponding coordinate in domainT Note this function might return a scalar (float, double, etc...) or a std::vector! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iiCrdTup</td><td>Input integer tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>domain space value. </dd></dl>

</div>
</div>
<a id="afce3c8dfd86a646cfbf7b62a673f3494" name="afce3c8dfd86a646cfbf7b62a673f3494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce3c8dfd86a646cfbf7b62a673f3494">&#9670;&#160;</a></span>iiCrdTup2domainVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abd496b12394781f40294fb4375a1fee7">rangeVectorT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::iiCrdTup2domainVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>iiCrdTup</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a packed integer coordinate tuple to the coorisponding <em>VECTOR</em> tuple of domRngBaseT Unlike iiCrdTup2domain, this function ALWAYS returns a vector! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iiCrdTup</td><td>Input integer tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>domain space value. </dd></dl>

</div>
</div>
<a id="a2025bddbd8b8e365ef1854c934c48ed8" name="a2025bddbd8b8e365ef1854c934c48ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2025bddbd8b8e365ef1854c934c48ed8">&#9670;&#160;</a></span>incAllCrd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::incAllCrd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>iiCrdTup</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Incriment all components in a a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iiCrdTup</td><td>The input tuple </td></tr>
    <tr><td class="paramname">value</td><td>Amout by which to increment each component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New tuple with incrimented components </dd></dl>

</div>
</div>
<a id="a38132e1b3bdc9de2cccc064d19874b66" name="a38132e1b3bdc9de2cccc064d19874b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38132e1b3bdc9de2cccc064d19874b66">&#9670;&#160;</a></span>incCrd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::incCrd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>iiCrdTup</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Incriment a component in a a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iiCrdTup</td><td>The input tuple </td></tr>
    <tr><td class="paramname">index</td><td>Which component to incriment </td></tr>
    <tr><td class="paramname">value</td><td>Amout by which to increment the component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New tuple with the specified component incrimented </dd></dl>

</div>
</div>
<a id="ad5873f343cf85a70650c92ff6729cd0d" name="ad5873f343cf85a70650c92ff6729cd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5873f343cf85a70650c92ff6729cd0d">&#9670;&#160;</a></span>refineOnce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::refineOnce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refine a cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Cell to refine &ndash; no error checking!! TODO: Add error checking. Return should be 1 if we refined, and 0 else. </td></tr>
    <tr><td class="paramname">func</td><td>Function to use for samples </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b39107cd836f7632c7bb10dfb597d3d" name="a7b39107cd836f7632c7bb10dfb597d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b39107cd836f7632c7bb10dfb597d3d">&#9670;&#160;</a></span>refineRecursive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::refineRecursive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refine a cell until refined cells reach specified depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Cell to refine </td></tr>
    <tr><td class="paramname">depth</td><td>Maximum depth of refined cells. -1 means refine to the limit. </td></tr>
    <tr><td class="paramname">func</td><td>Function to use for samples </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a826a4c3c021a3c24e19dcf59a0879356" name="a826a4c3c021a3c24e19dcf59a0879356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826a4c3c021a3c24e19dcf59a0879356">&#9670;&#160;</a></span>refineRecursiveCellPred()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::refineRecursiveCellPred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refine a cells matching predicate until refined cells reach specified depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Cell to refine </td></tr>
    <tr><td class="paramname">depth</td><td>Maximum depth of refinded cells. -1 means refine to the limit. </td></tr>
    <tr><td class="paramname">func</td><td>Function to use for samples </td></tr>
    <tr><td class="paramname">pred</td><td>Predicate function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d89ac404d2eb4274a0f7f6d85048149" name="a7d89ac404d2eb4274a0f7f6d85048149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d89ac404d2eb4274a0f7f6d85048149">&#9670;&#160;</a></span>refineRecursiveIfCellVertexIsNaN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::refineRecursiveIfCellVertexIsNaN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refine a cells with NaNs until refined cells reach specified depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Cell to refine </td></tr>
    <tr><td class="paramname">depth</td><td>Maximum depth of refinded cells. -1 means refine to the limit. </td></tr>
    <tr><td class="paramname">func</td><td>Function to use for samples </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ed46836b46fe14695b1617f2560417e" name="a6ed46836b46fe14695b1617f2560417e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed46836b46fe14695b1617f2560417e">&#9670;&#160;</a></span>sampleCell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::sampleCell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample a cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Cell to sample </td></tr>
    <tr><td class="paramname">func</td><td>Function to use for samples </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8145c6893b496f08be1a16d172de8e11" name="a8145c6893b496f08be1a16d172de8e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8145c6893b496f08be1a16d172de8e11">&#9670;&#160;</a></span>sampleFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::sampleFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample a function uniformly to a given cell depth. </p>
<p>The given cell need not exist in the tree yet. </p><dl class="section warning"><dt>Warning</dt><dd>Optimized to sample cells that have not been sampled previously. </dd>
<dd>
Will resample previously sampled points in the cell. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>THe cell to sample within </td></tr>
    <tr><td class="paramname">depth</td><td>The depth at which to sample depth=0 is equivilent to calling sampleCell(cell, func). depth=1 is equivilent to calling sampleCell(cell, func) followed by refineOnce(cell, func). </td></tr>
    <tr><td class="paramname">func</td><td>Function to use for samples </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06636b9cca675fccf7572a610e5bb73c" name="a06636b9cca675fccf7572a610e5bb73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06636b9cca675fccf7572a610e5bb73c">&#9670;&#160;</a></span>samplePoint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::samplePoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>iiCrdTup</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iiCrdTup</td><td>Point at which to sample </td></tr>
    <tr><td class="paramname">func</td><td>Function to sample </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a124c6d1f9738efed192073590660c1dd" name="a124c6d1f9738efed192073590660c1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124c6d1f9738efed192073590660c1dd">&#9670;&#160;</a></span>samplePointMaybe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::samplePointMaybe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>iiCrdTup</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#abbd5d4c5318f6fedf507ea075d22bcf2">rangeT</a>(<a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample a point if it has not already been sampled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iiCrdTup</td><td>Point at which to sample </td></tr>
    <tr><td class="paramname">func</td><td>Function to sample </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we sampled the point, and false otherwise. </dd></dl>

</div>
</div>
<a id="a54b37a4890bbaff06b93d2cfee09ba44" name="a54b37a4890bbaff06b93d2cfee09ba44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b37a4890bbaff06b93d2cfee09ba44">&#9670;&#160;</a></span>setAllCrd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::setAllCrd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ae9276573dd0bb3afc7b20dbf9a781d45">iCrdCmpT</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all components in a a tuple to a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value for each component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New tuple </dd></dl>

</div>
</div>
<a id="a9671e434f8cbcceb8022e28be0c2ae5f" name="a9671e434f8cbcceb8022e28be0c2ae5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9671e434f8cbcceb8022e28be0c2ae5f">&#9670;&#160;</a></span>setAspect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::setAspect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a></td>          <td class="paramname"><span class="paramname"><em>newAspect</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the aspect ratio. </p>
<dl class="section warning"><dt>Warning</dt><dd>No error checking &ndash; Correct operation only if all elements are positive and the length is rngDim </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newAspect</td><td>Value to sue for aspect <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2118796be825de409db28fc39b8e1ef5" name="a2118796be825de409db28fc39b8e1ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2118796be825de409db28fc39b8e1ef5">&#9670;&#160;</a></span>setBBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::setBBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a></td>          <td class="paramname"><span class="paramname"><em>newBBoxMin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a></td>          <td class="paramname"><span class="paramname"><em>newBBoxMax</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newBBoxMin</td><td>Value to use for bounding box minimum point </td></tr>
    <tr><td class="paramname">newBBoxMax</td><td>Value to use for bounding box maximum point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a187d3e2d55a8cd8da362ed63944f092d" name="a187d3e2d55a8cd8da362ed63944f092d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187d3e2d55a8cd8da362ed63944f092d">&#9670;&#160;</a></span>setBBoxMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::setBBoxMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a></td>          <td class="paramname"><span class="paramname"><em>newBBoxMax</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the bounding box maxDepth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newBBoxMax</td><td>Value to use for bounding box maximum point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14a51cf6c090035d9d9abc87b76c455d" name="a14a51cf6c090035d9d9abc87b76c455d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a51cf6c090035d9d9abc87b76c455d">&#9670;&#160;</a></span>setBBoxMin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::setBBoxMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af7dd7a32cbad34b0e20a31cd7a1aec52">domainT</a></td>          <td class="paramname"><span class="paramname"><em>newBBoxMin</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the bounding box minimum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newBBoxMin</td><td>Value to use for bounding box minimum point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee120c4451966cd9d7afa29fcd1b6c01" name="aee120c4451966cd9d7afa29fcd1b6c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee120c4451966cd9d7afa29fcd1b6c01">&#9670;&#160;</a></span>vertexExists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::vertexExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>vertex</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Point has been sampled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>Input vertex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acad249449b3c4a4288171c8226df0d72" name="acad249449b3c4a4288171c8226df0d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad249449b3c4a4288171c8226df0d72">&#9670;&#160;</a></span>vertexIsNaN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::vertexIsNaN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a></td>          <td class="paramname"><span class="paramname"><em>vertex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a vertex is NaN or, when it is a vector, if it contains a NaN element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>Input vertex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3cf9daed0c604d1bfd3145728f0b5402" name="a3cf9daed0c604d1bfd3145728f0b5402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf9daed0c604d1bfd3145728f0b5402">&#9670;&#160;</a></span>vi2iiCrdTup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ada13ac2ded350dced113d94e52264fa1">iiCrdTupT</a> <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::vi2iiCrdTup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a0b8008bf1a2994bb4cd2762b0eed8c74">viCrdTupT</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inVecTup</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an vector of integer coordinate tuple to an packed integer coordinate tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inVecTup</td><td>The vector of integer coordinate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New packed integer tuple. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aeebfd535f5d0f8196dcd0c3c07249245" name="aeebfd535f5d0f8196dcd0c3c07249245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebfd535f5d0f8196dcd0c3c07249245">&#9670;&#160;</a></span>iCrdCmpBits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::iCrdCmpBits = maxDepth+1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bits used by a single component of an integer coordinate tuple. </p>
<dl class="section warning"><dt>Warning</dt><dd>This might not be the size of iCrdCmpT! </dd></dl>

</div>
</div>
<a id="accb4f3cb8b2902b5d36e870e9cc56fa5" name="accb4f3cb8b2902b5d36e870e9cc56fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb4f3cb8b2902b5d36e870e9cc56fa5">&#9670;&#160;</a></span>iiCrdTupBits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int maxDepth, class domRngBaseT , int domDim, int rngDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmjr_1_1_m_r_p_tree.html">mjr::MRPTree</a>&lt; maxDepth, domRngBaseT, domDim, rngDim &gt;::iiCrdTupBits = <a class="el" href="#aeebfd535f5d0f8196dcd0c3c07249245">iCrdCmpBits</a> * domDim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bits used by an entire integer coordinate tuple. </p>
<dl class="section warning"><dt>Warning</dt><dd>This might not be the size of iiCrdCmpT! </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_m_r_p_tree_8hpp_source.html">MRPTree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
