<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: mjr::MR_rect_tree&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>mjr</b></li><li class="navelem"><a class="el" href="classmjr_1_1_m_r__rect__tree.html">MR_rect_tree</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classmjr_1_1_m_r__rect__tree-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mjr::MR_rect_tree&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Template Class used to house an <a class="el" href="classmjr_1_1_m_r__rect__tree.html" title="Template Class used to house an MR_rect_tree.">MR_rect_tree</a>.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_m_r__rect__tree_8hpp_source.html">MR_rect_tree.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8ea5fe20e6087596a5f857d88d9ae50c" id="r_a8ea5fe20e6087596a5f857d88d9ae50c"><td class="memItemLeft" align="right" valign="top"><a id="a8ea5fe20e6087596a5f857d88d9ae50c" name="a8ea5fe20e6087596a5f857d88d9ae50c"></a>
typedef spc_real_t&#160;</td><td class="memItemRight" valign="bottom"><b>src_t</b></td></tr>
<tr class="memdesc:a8ea5fe20e6087596a5f857d88d9ae50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Externally exposed typedef for spc_real_t. <br /></td></tr>
<tr class="separator:a8ea5fe20e6087596a5f857d88d9ae50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee784e59dea1572dcba405ab36f806d" id="r_acee784e59dea1572dcba405ab36f806d"><td class="memItemLeft" align="right" valign="top">typedef std::conditional&lt; std::cmp_equal(dom_dim, 1), <a class="el" href="#a8ea5fe20e6087596a5f857d88d9ae50c">src_t</a>, std::array&lt; <a class="el" href="#a8ea5fe20e6087596a5f857d88d9ae50c">src_t</a>, dom_dim &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a></td></tr>
<tr class="memdesc:acee784e59dea1572dcba405ab36f806d"><td class="mdescLeft">&#160;</td><td class="mdescRight">For values in the domain space.  <br /></td></tr>
<tr class="separator:acee784e59dea1572dcba405ab36f806d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5f7eaca21d05146fe210a996cc2eb4" id="r_a7d5f7eaca21d05146fe210a996cc2eb4"><td class="memItemLeft" align="right" valign="top"><a id="a7d5f7eaca21d05146fe210a996cc2eb4" name="a7d5f7eaca21d05146fe210a996cc2eb4"></a>
typedef <a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>real_domain_t</b></td></tr>
<tr class="memdesc:a7d5f7eaca21d05146fe210a996cc2eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A nicely descriptive typedef for drpt_t. <br /></td></tr>
<tr class="separator:a7d5f7eaca21d05146fe210a996cc2eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c09aa1e088f8739fa836dc43cdd7496" id="r_a3c09aa1e088f8739fa836dc43cdd7496"><td class="memItemLeft" align="right" valign="top"><a id="a3c09aa1e088f8739fa836dc43cdd7496" name="a3c09aa1e088f8739fa836dc43cdd7496"></a>
typedef std::vector&lt; <a class="el" href="#a8ea5fe20e6087596a5f857d88d9ae50c">src_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>drtv_t</b></td></tr>
<tr class="memdesc:a3c09aa1e088f8739fa836dc43cdd7496"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::vector for values in the domain space. <br /></td></tr>
<tr class="separator:a3c09aa1e088f8739fa836dc43cdd7496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cd339df201740643e296d1823c34d5" id="r_a90cd339df201740643e296d1823c34d5"><td class="memItemLeft" align="right" valign="top">typedef std::conditional&lt; std::cmp_equal(rng_dim, 1), <a class="el" href="#a8ea5fe20e6087596a5f857d88d9ae50c">src_t</a>, std::array&lt; <a class="el" href="#a8ea5fe20e6087596a5f857d88d9ae50c">src_t</a>, rng_dim &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a></td></tr>
<tr class="memdesc:a90cd339df201740643e296d1823c34d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For values in the range space.  <br /></td></tr>
<tr class="separator:a90cd339df201740643e296d1823c34d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83d86572eebb83a424ab84da0f02c4a" id="r_ab83d86572eebb83a424ab84da0f02c4a"><td class="memItemLeft" align="right" valign="top"><a id="ab83d86572eebb83a424ab84da0f02c4a" name="ab83d86572eebb83a424ab84da0f02c4a"></a>
typedef <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>real_range_t</b></td></tr>
<tr class="memdesc:ab83d86572eebb83a424ab84da0f02c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A nicely descriptive typedef for rrpt_t. <br /></td></tr>
<tr class="separator:ab83d86572eebb83a424ab84da0f02c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c405f3fbc8cbe6d263940f9825bc47c" id="r_a0c405f3fbc8cbe6d263940f9825bc47c"><td class="memItemLeft" align="right" valign="top"><a id="a0c405f3fbc8cbe6d263940f9825bc47c" name="a0c405f3fbc8cbe6d263940f9825bc47c"></a>
typedef std::array&lt; <a class="el" href="#a8ea5fe20e6087596a5f857d88d9ae50c">src_t</a>, dom_dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>drta_t</b></td></tr>
<tr class="memdesc:a0c405f3fbc8cbe6d263940f9825bc47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An std::array for points in the domain space. <br /></td></tr>
<tr class="separator:a0c405f3fbc8cbe6d263940f9825bc47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad526d4b1a983fc15420edd0a774309e6" id="r_ad526d4b1a983fc15420edd0a774309e6"><td class="memItemLeft" align="right" valign="top"><a id="ad526d4b1a983fc15420edd0a774309e6" name="ad526d4b1a983fc15420edd0a774309e6"></a>
typedef priv_dic_t&#160;</td><td class="memItemRight" valign="bottom"><b>dic_t</b></td></tr>
<tr class="memdesc:ad526d4b1a983fc15420edd0a774309e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type large large enough to hold an integer coordiante component. <br /></td></tr>
<tr class="separator:ad526d4b1a983fc15420edd0a774309e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866da9884b31c85dd487209bb6e0904f" id="r_a866da9884b31c85dd487209bb6e0904f"><td class="memItemLeft" align="right" valign="top"><a id="a866da9884b31c85dd487209bb6e0904f" name="a866da9884b31c85dd487209bb6e0904f"></a>
typedef priv_diti_t&#160;</td><td class="memItemRight" valign="bottom"><b>diti_t</b></td></tr>
<tr class="memdesc:a866da9884b31c85dd487209bb6e0904f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned integer type large large enough to hold an integer coordiante tuple. <br /></td></tr>
<tr class="separator:a866da9884b31c85dd487209bb6e0904f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cfe4c14b90a5b6de0d3fc0ff9da55b" id="r_a05cfe4c14b90a5b6de0d3fc0ff9da55b"><td class="memItemLeft" align="right" valign="top"><a id="a05cfe4c14b90a5b6de0d3fc0ff9da55b" name="a05cfe4c14b90a5b6de0d3fc0ff9da55b"></a>
typedef std::array&lt; <a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a>, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dita_t</b></td></tr>
<tr class="memdesc:a05cfe4c14b90a5b6de0d3fc0ff9da55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain point given as an std::array integer tuple. <br /></td></tr>
<tr class="separator:a05cfe4c14b90a5b6de0d3fc0ff9da55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afbaf494e81b09b5df44d32706000c9" id="r_a3afbaf494e81b09b5df44d32706000c9"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a></td></tr>
<tr class="memdesc:a3afbaf494e81b09b5df44d32706000c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A std::vector used to pass lists of diti_t types around.  <br /></td></tr>
<tr class="separator:a3afbaf494e81b09b5df44d32706000c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:ace85549f151a9b7d18e5086cf817570f" id="r_ace85549f151a9b7d18e5086cf817570f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace85549f151a9b7d18e5086cf817570f">MR_rect_tree</a> ()</td></tr>
<tr class="memdesc:ace85549f151a9b7d18e5086cf817570f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set real coordinate &amp; aspect ratio to defaults.  <br /></td></tr>
<tr class="separator:ace85549f151a9b7d18e5086cf817570f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3251efa8ecd83679e295aa2beacdefc" id="r_ac3251efa8ecd83679e295aa2beacdefc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3251efa8ecd83679e295aa2beacdefc">MR_rect_tree</a> (<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a> new_bbox_min, <a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a> new_bbox_max)</td></tr>
<tr class="memdesc:ac3251efa8ecd83679e295aa2beacdefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set real coordinate as specified &amp; aspect ratio to default.  <br /></td></tr>
<tr class="separator:ac3251efa8ecd83679e295aa2beacdefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27ca76c828fc9f3bc5c81b8a1a20374" id="r_ab27ca76c828fc9f3bc5c81b8a1a20374"><td class="memItemLeft" align="right" valign="top"><a id="ab27ca76c828fc9f3bc5c81b8a1a20374" name="ab27ca76c828fc9f3bc5c81b8a1a20374"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MR_rect_tree</b> (<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a> new_bbox_min, <a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a> new_bbox_max, <a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a> new_aspect)</td></tr>
<tr class="memdesc:ab27ca76c828fc9f3bc5c81b8a1a20374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set real coordinate &amp; aspect ratio as specified. <br /></td></tr>
<tr class="separator:ab27ca76c828fc9f3bc5c81b8a1a20374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction Helpers</div></td></tr>
<tr class="memitem:a8214acaf086127d31e48726a7bed588b" id="r_a8214acaf086127d31e48726a7bed588b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8214acaf086127d31e48726a7bed588b">update_bbox_delta</a> ()</td></tr>
<tr class="memdesc:a8214acaf086127d31e48726a7bed588b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the value of bbox_delta.  <br /></td></tr>
<tr class="separator:a8214acaf086127d31e48726a7bed588b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eae79256bb66862ec2c69375813b7ec" id="r_a7eae79256bb66862ec2c69375813b7ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7eae79256bb66862ec2c69375813b7ec">set_bbox</a> (<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a> new_bbox_min, <a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a> new_bbox_max)</td></tr>
<tr class="memdesc:a7eae79256bb66862ec2c69375813b7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounding box.  <br /></td></tr>
<tr class="separator:a7eae79256bb66862ec2c69375813b7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a2d766087555de8b4032e5ab9a762c" id="r_a41a2d766087555de8b4032e5ab9a762c"><td class="memItemLeft" align="right" valign="top"><a id="a41a2d766087555de8b4032e5ab9a762c" name="a41a2d766087555de8b4032e5ab9a762c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_bbox_default</b> ()</td></tr>
<tr class="memdesc:a41a2d766087555de8b4032e5ab9a762c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounding box to the default: -1 for all minimum components and +1 for all maximum components. <br /></td></tr>
<tr class="separator:a41a2d766087555de8b4032e5ab9a762c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07ef826ffd6427592276776a743562a" id="r_aa07ef826ffd6427592276776a743562a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa07ef826ffd6427592276776a743562a">set_bbox_min</a> (<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a> new_bbox_min)</td></tr>
<tr class="memdesc:aa07ef826ffd6427592276776a743562a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounding box minimum.  <br /></td></tr>
<tr class="separator:aa07ef826ffd6427592276776a743562a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad777497717a95a551b04c3b4d8223f14" id="r_ad777497717a95a551b04c3b4d8223f14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad777497717a95a551b04c3b4d8223f14">set_bbox_max</a> (<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a> new_bbox_max)</td></tr>
<tr class="memdesc:ad777497717a95a551b04c3b4d8223f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounding box max_depth.  <br /></td></tr>
<tr class="separator:ad777497717a95a551b04c3b4d8223f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c08270e89c63d78f4c35a7ea922c18" id="r_aa6c08270e89c63d78f4c35a7ea922c18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6c08270e89c63d78f4c35a7ea922c18">set_aspect</a> (<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a> new_aspect)</td></tr>
<tr class="memdesc:aa6c08270e89c63d78f4c35a7ea922c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the aspect ratio.  <br /></td></tr>
<tr class="separator:aa6c08270e89c63d78f4c35a7ea922c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b6c68902809452d4e6e4db3c8a148a" id="r_ad6b6c68902809452d4e6e4db3c8a148a"><td class="memItemLeft" align="right" valign="top"><a id="ad6b6c68902809452d4e6e4db3c8a148a" name="ad6b6c68902809452d4e6e4db3c8a148a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_aspect_default</b> ()</td></tr>
<tr class="memdesc:ad6b6c68902809452d4e6e4db3c8a148a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the aspect ratio to the default: 1.0 for all components. <br /></td></tr>
<tr class="separator:ad6b6c68902809452d4e6e4db3c8a148a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Basic Class Info</div></td></tr>
<tr class="memitem:ad70af90c1038d56811c0d30a153ba9bc" id="r_ad70af90c1038d56811c0d30a153ba9bc"><td class="memItemLeft" align="right" valign="top"><a id="ad70af90c1038d56811c0d30a153ba9bc" name="ad70af90c1038d56811c0d30a153ba9bc"></a>
<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_bbox_min</b> () const</td></tr>
<tr class="memdesc:ad70af90c1038d56811c0d30a153ba9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounding box minimum point. <br /></td></tr>
<tr class="separator:ad70af90c1038d56811c0d30a153ba9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac274883e439a675f44de9f2a6c6f8aa5" id="r_ac274883e439a675f44de9f2a6c6f8aa5"><td class="memItemLeft" align="right" valign="top"><a id="ac274883e439a675f44de9f2a6c6f8aa5" name="ac274883e439a675f44de9f2a6c6f8aa5"></a>
<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_bbox_max</b> () const</td></tr>
<tr class="memdesc:ac274883e439a675f44de9f2a6c6f8aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounding box minimum point. <br /></td></tr>
<tr class="separator:ac274883e439a675f44de9f2a6c6f8aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68236b95d8d4f5e85559e047b432b191" id="r_a68236b95d8d4f5e85559e047b432b191"><td class="memItemLeft" align="right" valign="top"><a id="a68236b95d8d4f5e85559e047b432b191" name="a68236b95d8d4f5e85559e047b432b191"></a>
<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_bbox_delta</b> () const</td></tr>
<tr class="memdesc:a68236b95d8d4f5e85559e047b432b191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounding box minimum point. <br /></td></tr>
<tr class="separator:a68236b95d8d4f5e85559e047b432b191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ece5310fbaa4e91d16df930aaa3f8f" id="r_a29ece5310fbaa4e91d16df930aaa3f8f"><td class="memItemLeft" align="right" valign="top"><a id="a29ece5310fbaa4e91d16df930aaa3f8f" name="a29ece5310fbaa4e91d16df930aaa3f8f"></a>
<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_aspect</b> () const</td></tr>
<tr class="memdesc:a29ece5310fbaa4e91d16df930aaa3f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the aspect vector. <br /></td></tr>
<tr class="separator:a29ece5310fbaa4e91d16df930aaa3f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae42e967c4706dece9e0fa03f2abba0e" id="r_aae42e967c4706dece9e0fa03f2abba0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae42e967c4706dece9e0fa03f2abba0e">get_sample</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> vertex)</td></tr>
<tr class="memdesc:aae42e967c4706dece9e0fa03f2abba0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample value for vertex.  <br /></td></tr>
<tr class="separator:aae42e967c4706dece9e0fa03f2abba0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755b14bc80c280943d668395099d3182" id="r_a755b14bc80c280943d668395099d3182"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>, <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a755b14bc80c280943d668395099d3182">cbegin_samples</a> ()</td></tr>
<tr class="memdesc:a755b14bc80c280943d668395099d3182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a constant forward iterator for the sample data.  <br /></td></tr>
<tr class="separator:a755b14bc80c280943d668395099d3182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c1a0e0ba605f2ff4ebdabd12cb27c0" id="r_aa1c1a0e0ba605f2ff4ebdabd12cb27c0"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; <a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>, <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1c1a0e0ba605f2ff4ebdabd12cb27c0">cend_samples</a> ()</td></tr>
<tr class="memdesc:aa1c1a0e0ba605f2ff4ebdabd12cb27c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a constant end iterator for the sample data.  <br /></td></tr>
<tr class="separator:aa1c1a0e0ba605f2ff4ebdabd12cb27c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell Oriented Coordinate Computation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions compute theoretical values based on a given cell center coordinate, and have nothing to do with sample state.</p>
<p>These functions preform various coordinate computation related to cells. For example, the <a class="el" href="#a57961e10e2b2a7d118024b1f10f358d5" title="Compute the top cell coordinates for the tree.">get_top_cell()</a> function returns the coordinates that would be used to identify the tree's top cell; however, this function tells us nothing about if that cell exists (as been sampled) in the tree.</p>
<p>In general these routines are optimized for performance, and do not preform any error checking. <br  />
</p>
<ul>
<li>Many functions require a valid cell coordinate (that is a coordinate that could be the center of a cell). For example, if one of these functions is given 0, then erroneous results are likely because 0 represents the coordinate for the corner of a tree which can never the the center of a cell.</li>
<li>When possible, the fewest coordinate components are used. For example <a class="el" href="#a9c79846d5482a3461e2d1ed60c8ecd44" title="Compute cell level.">cell_level()</a> uses just the first coordinate in it's computation. </li>
</ul>
</div></td></tr>
<tr class="memitem:a57961e10e2b2a7d118024b1f10f358d5" id="r_a57961e10e2b2a7d118024b1f10f358d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57961e10e2b2a7d118024b1f10f358d5">get_top_cell</a> () const</td></tr>
<tr class="memdesc:a57961e10e2b2a7d118024b1f10f358d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the top cell coordinates for the tree.  <br /></td></tr>
<tr class="separator:a57961e10e2b2a7d118024b1f10f358d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c79846d5482a3461e2d1ed60c8ecd44" id="r_a9c79846d5482a3461e2d1ed60c8ecd44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c79846d5482a3461e2d1ed60c8ecd44">cell_level</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:a9c79846d5482a3461e2d1ed60c8ecd44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cell level.  <br /></td></tr>
<tr class="separator:a9c79846d5482a3461e2d1ed60c8ecd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674c4274ee2b6704e6f84dc141858ecc" id="r_a674c4274ee2b6704e6f84dc141858ecc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a674c4274ee2b6704e6f84dc141858ecc">cell_half_width</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:a674c4274ee2b6704e6f84dc141858ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cell half width.  <br /></td></tr>
<tr class="separator:a674c4274ee2b6704e6f84dc141858ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ecfe83bcce1d2c0c726b82bfdf3128" id="r_a35ecfe83bcce1d2c0c726b82bfdf3128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35ecfe83bcce1d2c0c726b82bfdf3128">cell_quarter_width</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:a35ecfe83bcce1d2c0c726b82bfdf3128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cell quarter width.  <br /></td></tr>
<tr class="separator:a35ecfe83bcce1d2c0c726b82bfdf3128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c8af0d576d11517b96dde0783c7b17" id="r_ad9c8af0d576d11517b96dde0783c7b17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9c8af0d576d11517b96dde0783c7b17">cell_full_width</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:ad9c8af0d576d11517b96dde0783c7b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cell full width.  <br /></td></tr>
<tr class="separator:ad9c8af0d576d11517b96dde0783c7b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7db6390bfa0220ebba1cc31b1e4edd2" id="r_ac7db6390bfa0220ebba1cc31b1e4edd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7db6390bfa0220ebba1cc31b1e4edd2">cell_get_corner_min</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:ac7db6390bfa0220ebba1cc31b1e4edd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell first corner.  <br /></td></tr>
<tr class="separator:ac7db6390bfa0220ebba1cc31b1e4edd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7df46004858c6fb20fe08b90f4a0a1" id="r_a9c7df46004858c6fb20fe08b90f4a0a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c7df46004858c6fb20fe08b90f4a0a1">cell_get_corner_max</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:a9c7df46004858c6fb20fe08b90f4a0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cell last corner.  <br /></td></tr>
<tr class="separator:a9c7df46004858c6fb20fe08b90f4a0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08236214e061dba1350a7571767ed858" id="r_a08236214e061dba1350a7571767ed858"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08236214e061dba1350a7571767ed858">get_corners</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:a08236214e061dba1350a7571767ed858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the corners of the given cell.  <br /></td></tr>
<tr class="separator:a08236214e061dba1350a7571767ed858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f9a6878e2c47550c412784f1f06bdd" id="r_a05f9a6878e2c47550c412784f1f06bdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05f9a6878e2c47550c412784f1f06bdd">get_corners</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell, int index, int direction) const</td></tr>
<tr class="memdesc:a05f9a6878e2c47550c412784f1f06bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the corners of the given cell.  <br /></td></tr>
<tr class="separator:a05f9a6878e2c47550c412784f1f06bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4b13ba392599dcbfa93bf5e68b5a68" id="r_afa4b13ba392599dcbfa93bf5e68b5a68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa4b13ba392599dcbfa93bf5e68b5a68">get_neighbors</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:afa4b13ba392599dcbfa93bf5e68b5a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of neighbor cells of the specified cell.  <br /></td></tr>
<tr class="separator:afa4b13ba392599dcbfa93bf5e68b5a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468913422a82e42579101305cdbe9f46" id="r_a468913422a82e42579101305cdbe9f46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a468913422a82e42579101305cdbe9f46">get_neighbor</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell, int index, int direction) const</td></tr>
<tr class="memdesc:a468913422a82e42579101305cdbe9f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the neighbor cell along the given axis in the specified direction.  <br /></td></tr>
<tr class="separator:a468913422a82e42579101305cdbe9f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3907e8778faa5fa166483328904f0ae6" id="r_a3907e8778faa5fa166483328904f0ae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3907e8778faa5fa166483328904f0ae6">get_children</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:a3907e8778faa5fa166483328904f0ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of child cells of the specified cell If cell can't have children because it is at maximal depth, then an empty vector is returned.  <br /></td></tr>
<tr class="separator:a3907e8778faa5fa166483328904f0ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939db86e6333d52cd30b3f6607229873" id="r_a939db86e6333d52cd30b3f6607229873"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a939db86e6333d52cd30b3f6607229873">get_children</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell, int index, int direction) const</td></tr>
<tr class="memdesc:a939db86e6333d52cd30b3f6607229873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of child cells of the specified cell An empty vector is returned if no children are possible.  <br /></td></tr>
<tr class="separator:a939db86e6333d52cd30b3f6607229873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c472751d365a54d07de55387bf9ced2" id="r_a2c472751d365a54d07de55387bf9ced2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c472751d365a54d07de55387bf9ced2">get_vertexes</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:a2c472751d365a54d07de55387bf9ced2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the vertexes (corners and center) of the given cell.  <br /></td></tr>
<tr class="separator:a2c472751d365a54d07de55387bf9ced2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low Level Integer Tuple Computation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These functions encapsulate various coordinate computations.</p>
<p>In general these routines are optimized for performance, and do not preform any error checking. For example it is possible to underflow/overflow with inappropriate values. </p>
</div></td></tr>
<tr class="memitem:a8d9aea0affefa3fc3e8f99fa96266092" id="r_a8d9aea0affefa3fc3e8f99fa96266092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d9aea0affefa3fc3e8f99fa96266092">get_crd</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> diti, int index) const</td></tr>
<tr class="memdesc:a8d9aea0affefa3fc3e8f99fa96266092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a component from a tuple.  <br /></td></tr>
<tr class="separator:a8d9aea0affefa3fc3e8f99fa96266092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf094d9a3cb139f037d777712b1b79c5" id="r_aaf094d9a3cb139f037d777712b1b79c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf094d9a3cb139f037d777712b1b79c5">inc_crd</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> diti, int index, <a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a> value) const</td></tr>
<tr class="memdesc:aaf094d9a3cb139f037d777712b1b79c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incriment a component in a a tuple.  <br /></td></tr>
<tr class="separator:aaf094d9a3cb139f037d777712b1b79c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31e6c7fe35bbae1c53d9484440e4e78" id="r_af31e6c7fe35bbae1c53d9484440e4e78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af31e6c7fe35bbae1c53d9484440e4e78">dec_crd</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> diti, int index, <a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a> value) const</td></tr>
<tr class="memdesc:af31e6c7fe35bbae1c53d9484440e4e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decriment a component in a a tuple.  <br /></td></tr>
<tr class="separator:af31e6c7fe35bbae1c53d9484440e4e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b83e83767379e37bb18b15f856bca8" id="r_a18b83e83767379e37bb18b15f856bca8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18b83e83767379e37bb18b15f856bca8">dec_all_crd</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> diti, <a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a> value) const</td></tr>
<tr class="memdesc:a18b83e83767379e37bb18b15f856bca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decriment all components in a a tuple.  <br /></td></tr>
<tr class="separator:a18b83e83767379e37bb18b15f856bca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172523e2e85ca845d72a3a6d365eadf6" id="r_a172523e2e85ca845d72a3a6d365eadf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a172523e2e85ca845d72a3a6d365eadf6">inc_all_crd</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> diti, <a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a> value) const</td></tr>
<tr class="memdesc:a172523e2e85ca845d72a3a6d365eadf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incriment all components in a a tuple.  <br /></td></tr>
<tr class="separator:a172523e2e85ca845d72a3a6d365eadf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e97f695e45c2c005512144a9596e904" id="r_a5e97f695e45c2c005512144a9596e904"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e97f695e45c2c005512144a9596e904">set_all_crd</a> (<a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a> value) const</td></tr>
<tr class="memdesc:a5e97f695e45c2c005512144a9596e904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all components in a a tuple to a constant.  <br /></td></tr>
<tr class="separator:a5e97f695e45c2c005512144a9596e904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f3049d5dc8469b96b290c14040808e" id="r_ac1f3049d5dc8469b96b290c14040808e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1f3049d5dc8469b96b290c14040808e">get_two_cross</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> diti, <a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a> delta) const</td></tr>
<tr class="memdesc:ac1f3049d5dc8469b96b290c14040808e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute cross product points centered at diti and delta away TODO: Should this be private? TODO: If diti is close to an corner, then some of the cross product points may be out of range.  <br /></td></tr>
<tr class="separator:ac1f3049d5dc8469b96b290c14040808e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29922671bfa697da72c46b613fa9f09" id="r_ab29922671bfa697da72c46b613fa9f09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab29922671bfa697da72c46b613fa9f09">get_two_cross</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> diti, <a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a> delta, int index, int direction) const</td></tr>
<tr class="memdesc:ab29922671bfa697da72c46b613fa9f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute directional cross product points centered at diti and delta away.  <br /></td></tr>
<tr class="separator:ab29922671bfa697da72c46b613fa9f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1086fa9368027d1e3ae8a890a47a702a" id="r_a1086fa9368027d1e3ae8a890a47a702a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1086fa9368027d1e3ae8a890a47a702a">get_axis_cross</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> diti, <a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a> delta) const</td></tr>
<tr class="memdesc:a1086fa9368027d1e3ae8a890a47a702a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute axis aligned cross points centered at diti and delta away TODO: Should this be private? Axis aligned cross points that fall outside of the domain will not be returned.  <br /></td></tr>
<tr class="separator:a1086fa9368027d1e3ae8a890a47a702a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Easy way to treat rrpt_t &amp; drpt_t types as indexable regardless of dom_dim &amp; rng_dim.</div></td></tr>
<tr><td colspan="2"><div class="groupHeader">Packed Integer Tuple &lt;-&gt; Vector of Integer Tuple Conversions</div></td></tr>
<tr class="memitem:a96f1e2a8c540677065f7a2b38e139708" id="r_a96f1e2a8c540677065f7a2b38e139708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96f1e2a8c540677065f7a2b38e139708">dita_to_diti</a> (const <a class="el" href="#a05cfe4c14b90a5b6de0d3fc0ff9da55b">dita_t</a> &amp;dita) const</td></tr>
<tr class="memdesc:a96f1e2a8c540677065f7a2b38e139708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an vector of integer coordinate tuple to an packed integer coordinate tuple.  <br /></td></tr>
<tr class="separator:a96f1e2a8c540677065f7a2b38e139708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab403e84cab06928c29309ba94a1bb4b5" id="r_ab403e84cab06928c29309ba94a1bb4b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a05cfe4c14b90a5b6de0d3fc0ff9da55b">dita_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab403e84cab06928c29309ba94a1bb4b5">diti_to_dita</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> diti) const</td></tr>
<tr class="memdesc:ab403e84cab06928c29309ba94a1bb4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a packed integer coordinate tuple to a vector of integer coordinate tuple Note dita_t is <em>always</em> a vector even when dom_dim==1.  <br /></td></tr>
<tr class="separator:ab403e84cab06928c29309ba94a1bb4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Integer Tuple to Domain Space Tuple Conversion</div></td></tr>
<tr class="memitem:a3534cbe683cd7b487647cdb5f4828ec5" id="r_a3534cbe683cd7b487647cdb5f4828ec5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3534cbe683cd7b487647cdb5f4828ec5">diti_to_drpt</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> diti) const</td></tr>
<tr class="memdesc:a3534cbe683cd7b487647cdb5f4828ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a packed integer coordinate tuple to the coorisponding coordinate in drpt_t Note this function might return a scalar (float, double, etc...) or a std::vector!  <br /></td></tr>
<tr class="separator:a3534cbe683cd7b487647cdb5f4828ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd5439e8b8f8b910c87b544b4a072e1" id="r_a5cd5439e8b8f8b910c87b544b4a072e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a0c405f3fbc8cbe6d263940f9825bc47c">drta_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cd5439e8b8f8b910c87b544b4a072e1">diti_to_drta</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> diti) const</td></tr>
<tr class="memdesc:a5cd5439e8b8f8b910c87b544b4a072e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a packed integer coordinate tuple to the coorisponding <em>VECTOR</em> tuple of src_t Unlike diti_to_drpt, this function ALWAYS returns a vector!  <br /></td></tr>
<tr class="separator:a5cd5439e8b8f8b910c87b544b4a072e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Function Sampleing</div></td></tr>
<tr class="memitem:abc142bafa00a1ae8d627dfe4857156d2" id="r_abc142bafa00a1ae8d627dfe4857156d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc142bafa00a1ae8d627dfe4857156d2">sample_function</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell, int depth, std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt; func)</td></tr>
<tr class="memdesc:abc142bafa00a1ae8d627dfe4857156d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a function uniformly to a given cell depth.  <br /></td></tr>
<tr class="separator:abc142bafa00a1ae8d627dfe4857156d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851cd97f67c27024121b1493f94da82e" id="r_a851cd97f67c27024121b1493f94da82e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a851cd97f67c27024121b1493f94da82e">refine_recursive</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell, int depth, std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt; func)</td></tr>
<tr class="memdesc:a851cd97f67c27024121b1493f94da82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine a cell until refined cells reach specified depth.  <br /></td></tr>
<tr class="separator:a851cd97f67c27024121b1493f94da82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409b4f56ff71edb6a528539a39b2e6b0" id="r_a409b4f56ff71edb6a528539a39b2e6b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a409b4f56ff71edb6a528539a39b2e6b0">refine_recursive_cell_pred</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell, int depth, std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt; func, std::function&lt; bool(<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>)&gt; pred)</td></tr>
<tr class="memdesc:a409b4f56ff71edb6a528539a39b2e6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine a cells matching predicate until refined cells reach specified depth.  <br /></td></tr>
<tr class="separator:a409b4f56ff71edb6a528539a39b2e6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddcfaf68f0fd352edc8c44b7ba3b3ef" id="r_a0ddcfaf68f0fd352edc8c44b7ba3b3ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ddcfaf68f0fd352edc8c44b7ba3b3ef">refine_recursive_if_cell_vertex_is_nan</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell, int depth, std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt; func)</td></tr>
<tr class="memdesc:a0ddcfaf68f0fd352edc8c44b7ba3b3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine a cells with NaNs until refined cells reach specified depth.  <br /></td></tr>
<tr class="separator:a0ddcfaf68f0fd352edc8c44b7ba3b3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d3c9171a8dc7a657464d83903a434c" id="r_a83d3c9171a8dc7a657464d83903a434c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83d3c9171a8dc7a657464d83903a434c">refine_once</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell, std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt; func)</td></tr>
<tr class="memdesc:a83d3c9171a8dc7a657464d83903a434c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine a cell.  <br /></td></tr>
<tr class="separator:a83d3c9171a8dc7a657464d83903a434c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eecff4d5168731756a7991e63fb0bed" id="r_a6eecff4d5168731756a7991e63fb0bed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eecff4d5168731756a7991e63fb0bed">sample_cell</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell, std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt; func)</td></tr>
<tr class="memdesc:a6eecff4d5168731756a7991e63fb0bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a cell.  <br /></td></tr>
<tr class="separator:a6eecff4d5168731756a7991e63fb0bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2191bd9f101510576b6d188e19263ef8" id="r_a2191bd9f101510576b6d188e19263ef8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2191bd9f101510576b6d188e19263ef8">sample_point_maybe</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> diti, std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt; func)</td></tr>
<tr class="memdesc:a2191bd9f101510576b6d188e19263ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a point if it has not already been sampled.  <br /></td></tr>
<tr class="separator:a2191bd9f101510576b6d188e19263ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce320d58ac8a0954f2364a85c73a6ee" id="r_a0ce320d58ac8a0954f2364a85c73a6ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ce320d58ac8a0954f2364a85c73a6ee">sample_point</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> diti, std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt; func)</td></tr>
<tr class="memdesc:a0ce320d58ac8a0954f2364a85c73a6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a point.  <br /></td></tr>
<tr class="separator:a0ce320d58ac8a0954f2364a85c73a6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell Predicates</div></td></tr>
<tr class="memitem:a8fd1a293eb3d7610ad1c3cfbd9df575b" id="r_a8fd1a293eb3d7610ad1c3cfbd9df575b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fd1a293eb3d7610ad1c3cfbd9df575b">cell_good_cords</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:a8fd1a293eb3d7610ad1c3cfbd9df575b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if cell coordinates are in range to be a cell center.  <br /></td></tr>
<tr class="separator:a8fd1a293eb3d7610ad1c3cfbd9df575b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f9261588ee6b95c22275137295c593" id="r_ab2f9261588ee6b95c22275137295c593"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2f9261588ee6b95c22275137295c593">cell_exists</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:ab2f9261588ee6b95c22275137295c593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell has been sampled.  <br /></td></tr>
<tr class="separator:ab2f9261588ee6b95c22275137295c593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947b0c2e201510e2b98c60a7d69d9118" id="r_a947b0c2e201510e2b98c60a7d69d9118"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a947b0c2e201510e2b98c60a7d69d9118">cell_good_samples</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:a947b0c2e201510e2b98c60a7d69d9118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell has been sampled.  <br /></td></tr>
<tr class="separator:a947b0c2e201510e2b98c60a7d69d9118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c421066434d14763bde9c364c768b70" id="r_a5c421066434d14763bde9c364c768b70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c421066434d14763bde9c364c768b70">cell_vertex_is_nan</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell)</td></tr>
<tr class="memdesc:a5c421066434d14763bde9c364c768b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell has a vertex with a NaN value for a sample.  <br /></td></tr>
<tr class="separator:a5c421066434d14763bde9c364c768b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb58d06a964c64bb34a8c8703d4a28d" id="r_a9cb58d06a964c64bb34a8c8703d4a28d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cb58d06a964c64bb34a8c8703d4a28d">cell_corner_is_nan</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell)</td></tr>
<tr class="memdesc:a9cb58d06a964c64bb34a8c8703d4a28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell has an corner with a NaN value for a sample.  <br /></td></tr>
<tr class="separator:a9cb58d06a964c64bb34a8c8703d4a28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa6cf0fb08e3f960c9f09fe1b044760" id="r_a9fa6cf0fb08e3f960c9f09fe1b044760"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fa6cf0fb08e3f960c9f09fe1b044760">cell_has_child</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:a9fa6cf0fb08e3f960c9f09fe1b044760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell has children.  <br /></td></tr>
<tr class="separator:a9fa6cf0fb08e3f960c9f09fe1b044760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39924936ad3a5a8fc897d180efe207e1" id="r_a39924936ad3a5a8fc897d180efe207e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39924936ad3a5a8fc897d180efe207e1">cell_has_no_child</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:a39924936ad3a5a8fc897d180efe207e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell has no children.  <br /></td></tr>
<tr class="separator:a39924936ad3a5a8fc897d180efe207e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c8c29245be671f3858a2fdbb98129e" id="r_a31c8c29245be671f3858a2fdbb98129e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31c8c29245be671f3858a2fdbb98129e">cell_can_have_children</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:a31c8c29245be671f3858a2fdbb98129e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell can have children (it not of minimal size)  <br /></td></tr>
<tr class="separator:a31c8c29245be671f3858a2fdbb98129e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d727b20bb519caea074c07eeba250b" id="r_ad6d727b20bb519caea074c07eeba250b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6d727b20bb519caea074c07eeba250b">cell_has_neighbor</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell, int index, int direction)</td></tr>
<tr class="memdesc:ad6d727b20bb519caea074c07eeba250b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the specified neighbor cell exixts (is smapled).  <br /></td></tr>
<tr class="separator:ad6d727b20bb519caea074c07eeba250b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7753832f5a627a49ab9f782a7873e81b" id="r_a7753832f5a627a49ab9f782a7873e81b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7753832f5a627a49ab9f782a7873e81b">cell_cross_sdf</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell, std::function&lt; <a class="el" href="#a8ea5fe20e6087596a5f857d88d9ae50c">src_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt; signFunc)</td></tr>
<tr class="memdesc:a7753832f5a627a49ab9f782a7873e81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a cell crosses a signed distance function boundry.  <br /></td></tr>
<tr class="separator:a7753832f5a627a49ab9f782a7873e81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vertex Predicates</div></td></tr>
<tr class="memitem:a8c1d32162e94aeeea138def8f0b64ca2" id="r_a8c1d32162e94aeeea138def8f0b64ca2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c1d32162e94aeeea138def8f0b64ca2">vertex_is_nan</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> vertex)</td></tr>
<tr class="memdesc:a8c1d32162e94aeeea138def8f0b64ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if a vertex is NaN or, when it is a vector, if it contains a NaN element.  <br /></td></tr>
<tr class="separator:a8c1d32162e94aeeea138def8f0b64ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4209d3fa754d39fb246573f758b5b5b" id="r_aa4209d3fa754d39fb246573f758b5b5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4209d3fa754d39fb246573f758b5b5b">vertex_exists</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> vertex) const</td></tr>
<tr class="memdesc:aa4209d3fa754d39fb246573f758b5b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point has been sampled.  <br /></td></tr>
<tr class="separator:aa4209d3fa754d39fb246573f758b5b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extract Cells</div></td></tr>
<tr class="memitem:a6d074ff007886f4a3187c31c20f75d9e" id="r_a6d074ff007886f4a3187c31c20f75d9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d074ff007886f4a3187c31c20f75d9e">get_leaf_cells</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:a6d074ff007886f4a3187c31c20f75d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a list of all leaf cells starting from the given cell.  <br /></td></tr>
<tr class="separator:a6d074ff007886f4a3187c31c20f75d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764c96e23d3d3fce2ecd638c63f2ce4f" id="r_a764c96e23d3d3fce2ecd638c63f2ce4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a764c96e23d3d3fce2ecd638c63f2ce4f">get_leaf_cells</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell, int index, int direction) const</td></tr>
<tr class="memdesc:a764c96e23d3d3fce2ecd638c63f2ce4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a list of all leaf cells starting from the given cell.  <br /></td></tr>
<tr class="separator:a764c96e23d3d3fce2ecd638c63f2ce4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9833d9d86a71b70596fb7f1b3bf237" id="r_acf9833d9d86a71b70596fb7f1b3bf237"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf9833d9d86a71b70596fb7f1b3bf237">count_leaf_cells</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell) const</td></tr>
<tr class="memdesc:acf9833d9d86a71b70596fb7f1b3bf237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of leaf cells starting from the given cell.  <br /></td></tr>
<tr class="separator:acf9833d9d86a71b70596fb7f1b3bf237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb1bf963d9e37e1ac5947ab7f93b23a" id="r_aefb1bf963d9e37e1ac5947ab7f93b23a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefb1bf963d9e37e1ac5947ab7f93b23a">get_existing_neighbor</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> cell, int index, int direction) const</td></tr>
<tr class="memdesc:aefb1bf963d9e37e1ac5947ab7f93b23a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of sampled neighbors to the given cell.  <br /></td></tr>
<tr class="separator:aefb1bf963d9e37e1ac5947ab7f93b23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Debug</div></td></tr>
<tr class="memitem:aa24ab4fd1dc468fd12741b5f936da140" id="r_aa24ab4fd1dc468fd12741b5f936da140"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa24ab4fd1dc468fd12741b5f936da140">diti_to_string</a> (<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> diti, bool includeDomain, bool doHex) const</td></tr>
<tr class="memdesc:aa24ab4fd1dc468fd12741b5f936da140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a diti_t to a string representation.  <br /></td></tr>
<tr class="separator:aa24ab4fd1dc468fd12741b5f936da140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56228ad1852edb19a69980b66869cdd9" id="r_a56228ad1852edb19a69980b66869cdd9"><td class="memItemLeft" align="right" valign="top"><a id="a56228ad1852edb19a69980b66869cdd9" name="a56228ad1852edb19a69980b66869cdd9"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>drpt_ttoString</b> (<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a> x) const</td></tr>
<tr class="memdesc:a56228ad1852edb19a69980b66869cdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a drpt_t to a string representation. <br /></td></tr>
<tr class="separator:a56228ad1852edb19a69980b66869cdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afbfe981dd0ae193419c75f6b9136cd" id="r_a4afbfe981dd0ae193419c75f6b9136cd"><td class="memItemLeft" align="right" valign="top"><a id="a4afbfe981dd0ae193419c75f6b9136cd" name="a4afbfe981dd0ae193419c75f6b9136cd"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>rrpt_ttoString</b> (<a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a> x) const</td></tr>
<tr class="memdesc:a4afbfe981dd0ae193419c75f6b9136cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a rrpt_t to a string representation. <br /></td></tr>
<tr class="separator:a4afbfe981dd0ae193419c75f6b9136cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ad9ca843261c23a08e5e5ecfcc7146" id="r_aa0ad9ca843261c23a08e5e5ecfcc7146"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0ad9ca843261c23a08e5e5ecfcc7146">dump_tree</a> (int maxNumPrint) const</td></tr>
<tr class="memdesc:aa0ad9ca843261c23a08e5e5ecfcc7146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump tree to STDOUT.  <br /></td></tr>
<tr class="separator:aa0ad9ca843261c23a08e5e5ecfcc7146"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa0d3c3178b1ef02e91599159bafd69ee" id="r_aa0d3c3178b1ef02e91599159bafd69ee"><td class="memItemLeft" align="right" valign="top"><a id="aa0d3c3178b1ef02e91599159bafd69ee" name="aa0d3c3178b1ef02e91599159bafd69ee"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>domain_dimension</b> = dom_dim</td></tr>
<tr class="memdesc:aa0d3c3178b1ef02e91599159bafd69ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the template parameter dom_dim. <br /></td></tr>
<tr class="separator:aa0d3c3178b1ef02e91599159bafd69ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437d544809203c07392b4b0fbf30eb85" id="r_a437d544809203c07392b4b0fbf30eb85"><td class="memItemLeft" align="right" valign="top"><a id="a437d544809203c07392b4b0fbf30eb85" name="a437d544809203c07392b4b0fbf30eb85"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>range_dimension</b> = rng_dim</td></tr>
<tr class="memdesc:a437d544809203c07392b4b0fbf30eb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the template parameter rng_dim. <br /></td></tr>
<tr class="separator:a437d544809203c07392b4b0fbf30eb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a3fcdab7123ef5cd5b6988f63bd9c2" id="r_a09a3fcdab7123ef5cd5b6988f63bd9c2"><td class="memItemLeft" align="right" valign="top"><a id="a09a3fcdab7123ef5cd5b6988f63bd9c2" name="a09a3fcdab7123ef5cd5b6988f63bd9c2"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>maximum_depth</b> = max_depth</td></tr>
<tr class="memdesc:a09a3fcdab7123ef5cd5b6988f63bd9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the template parameter max_depth. <br /></td></tr>
<tr class="separator:a09a3fcdab7123ef5cd5b6988f63bd9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a9e142dc8061f82e852517784fda84" id="r_a94a9e142dc8061f82e852517784fda84"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94a9e142dc8061f82e852517784fda84">dic_bits</a> = max_depth+1</td></tr>
<tr class="memdesc:a94a9e142dc8061f82e852517784fda84"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bits used by a single component of an integer coordinate tuple.  <br /></td></tr>
<tr class="separator:a94a9e142dc8061f82e852517784fda84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ace574289540a0436f779dd38b506a" id="r_a08ace574289540a0436f779dd38b506a"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08ace574289540a0436f779dd38b506a">diti_bits</a> = <a class="el" href="#a94a9e142dc8061f82e852517784fda84">dic_bits</a> * dom_dim</td></tr>
<tr class="memdesc:a08ace574289540a0436f779dd38b506a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bits used by an entire integer coordinate tuple.  <br /></td></tr>
<tr class="separator:a08ace574289540a0436f779dd38b506a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc568942c27da86013ab39dec09688aa" id="r_afc568942c27da86013ab39dec09688aa"><td class="memItemLeft" align="right" valign="top"><a id="afc568942c27da86013ab39dec09688aa" name="afc568942c27da86013ab39dec09688aa"></a>
static constexpr <a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dic_max</b> = (static_cast&lt;<a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a>&gt;(1) &lt;&lt; max_depth)</td></tr>
<tr class="memdesc:afc568942c27da86013ab39dec09688aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowd for a dic_t. <br /></td></tr>
<tr class="separator:afc568942c27da86013ab39dec09688aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a28ab06ed8ba1a66578c731508092d" id="r_ab1a28ab06ed8ba1a66578c731508092d"><td class="memItemLeft" align="right" valign="top"><a id="ab1a28ab06ed8ba1a66578c731508092d" name="ab1a28ab06ed8ba1a66578c731508092d"></a>
static constexpr <a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dic_ctr</b> = (static_cast&lt;<a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a>&gt;(1) &lt;&lt; (max_depth-1))</td></tr>
<tr class="memdesc:ab1a28ab06ed8ba1a66578c731508092d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Center value for a dic_t. <br /></td></tr>
<tr class="separator:ab1a28ab06ed8ba1a66578c731508092d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782e56eebd23c6394d4c51b97602fa42" id="r_a782e56eebd23c6394d4c51b97602fa42"><td class="memItemLeft" align="right" valign="top"><a id="a782e56eebd23c6394d4c51b97602fa42" name="a782e56eebd23c6394d4c51b97602fa42"></a>
static constexpr <a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dic_min</b> = 0</td></tr>
<tr class="memdesc:a782e56eebd23c6394d4c51b97602fa42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum allowd for a dic_t. <br /></td></tr>
<tr class="separator:a782e56eebd23c6394d4c51b97602fa42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int max_depth, class spc_real_t, int dom_dim, int rng_dim&gt;<br />
requires ((max_depth&gt;0) &amp;&amp; (dom_dim&gt;0) &amp;&amp; (rng_dim&gt;0) &amp;&amp; (dom_dim*max_depth&lt;=CHAR_BIT*sizeof(uint64_t)) &amp;&amp; (std::is_floating_point&lt;spc_real_t&gt;::value))<br />
class mjr::MR_rect_tree&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;</div><p>Template Class used to house an <a class="el" href="classmjr_1_1_m_r__rect__tree.html" title="Template Class used to house an MR_rect_tree.">MR_rect_tree</a>. </p>
<p>For a function f:R^2-&gt;R^3, we might use:</p><ul>
<li>spc_real_t = double</li>
<li>dom_dim = 2</li>
<li>rng_dim = 3</li>
<li>max_depth = 7 or 15</li>
</ul>
<p>Type Naming Conventions</p><ul>
<li>Coordinate<ul>
<li>Domain<ul>
<li>dic_t (domain Integer Coordinate) &ndash; A single integer</li>
<li>src_t (space Real Coordinate) &ndash; Floating point</li>
</ul>
</li>
</ul>
</li>
<li>Coordinate Tuples<ul>
<li>Domain Integer Tuples<ul>
<li>diti_t (domain int tuple Integer) &ndash; Encoded as a packed integer</li>
<li>dita_t (domain int tuple Array) &ndash; As a dom_dim element std::array</li>
<li>ditv_t (domain int tuple Vector) &ndash; As a dom_dim element std::vector</li>
</ul>
</li>
<li>Domain/range real tuples<ul>
<li>rrta_t/drta_t (range/domain real tuple Array) &ndash; As a dom_dim/rng_dim element std::array</li>
<li>rrtv_t/drtv_t (range/domain real tuple Vector) &ndash; As a dom_dim/rng_dim element std::vector</li>
<li>rrpt_t/drpt_t (range/domain real psudo-tuple) &ndash; As a src_t when dim==1, and an array otherwise Function arguments of type 'foo_t' are frequently called 'foo'.</li>
</ul>
</li>
</ul>
</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">max_depth</td><td>The maximum depth of the tree &ndash; use one minus a power of two for highest performance. </td></tr>
    <tr><td class="paramname">spc_real_t</td><td>The base floating type to use for both domain &amp; range. </td></tr>
    <tr><td class="paramname">dom_dim</td><td>Domain dimension. </td></tr>
    <tr><td class="paramname">rng_dim</td><td>Range dimension. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3afbaf494e81b09b5df44d32706000c9" name="a3afbaf494e81b09b5df44d32706000c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afbaf494e81b09b5df44d32706000c9">&#9670;&#160;</a></span>diti_list_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>&gt; <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::diti_list_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A std::vector used to pass lists of diti_t types around. </p>
<p><br  />
 </p>

</div>
</div>
<a id="acee784e59dea1572dcba405ab36f806d" name="acee784e59dea1572dcba405ab36f806d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee784e59dea1572dcba405ab36f806d">&#9670;&#160;</a></span>drpt_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::conditional&lt;std::cmp_equal(dom_dim,1),<a class="el" href="#a8ea5fe20e6087596a5f857d88d9ae50c">src_t</a>,std::array&lt;<a class="el" href="#a8ea5fe20e6087596a5f857d88d9ae50c">src_t</a>,dom_dim&gt;&gt;::type <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::drpt_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For values in the domain space. </p>
<ul>
<li>When dom_dim==1, this will be src_t</li>
<li>When dom_dim!=1, this will be drta_t (an std::array) See also rrpt_t. </li>
</ul>

</div>
</div>
<a id="a90cd339df201740643e296d1823c34d5" name="a90cd339df201740643e296d1823c34d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cd339df201740643e296d1823c34d5">&#9670;&#160;</a></span>rrpt_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::conditional&lt;std::cmp_equal(rng_dim,1),<a class="el" href="#a8ea5fe20e6087596a5f857d88d9ae50c">src_t</a>,std::array&lt;<a class="el" href="#a8ea5fe20e6087596a5f857d88d9ae50c">src_t</a>,rng_dim&gt;&gt;::type <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::rrpt_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For values in the range space. </p>
<ul>
<li>When rng_dim==1, this will be src_t</li>
<li>When rng_dim!=1, this will be a rrta_t (an std::array) See also drpt_t. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ace85549f151a9b7d18e5086cf817570f" name="ace85549f151a9b7d18e5086cf817570f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace85549f151a9b7d18e5086cf817570f">&#9670;&#160;</a></span>MR_rect_tree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::MR_rect_tree </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set real coordinate &amp; aspect ratio to defaults. </p>
<p>see: <a class="el" href="#a41a2d766087555de8b4032e5ab9a762c" title="Set the bounding box to the default: -1 for all minimum components and +1 for all maximum components.">set_bbox_default()</a> &amp; <a class="el" href="#ad6b6c68902809452d4e6e4db3c8a148a" title="Set the aspect ratio to the default: 1.0 for all components.">set_aspect_default()</a>. </p>

</div>
</div>
<a id="ac3251efa8ecd83679e295aa2beacdefc" name="ac3251efa8ecd83679e295aa2beacdefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3251efa8ecd83679e295aa2beacdefc">&#9670;&#160;</a></span>MR_rect_tree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::MR_rect_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a></td>          <td class="paramname"><span class="paramname"><em>new_bbox_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a></td>          <td class="paramname"><span class="paramname"><em>new_bbox_max</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set real coordinate as specified &amp; aspect ratio to default. </p>
<p>see: <a class="el" href="#ad6b6c68902809452d4e6e4db3c8a148a" title="Set the aspect ratio to the default: 1.0 for all components.">set_aspect_default()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_bbox_min</td><td>Value to use for bounding box minimum point </td></tr>
    <tr><td class="paramname">new_bbox_max</td><td>Value to use for bounding box maximum point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a755b14bc80c280943d668395099d3182" name="a755b14bc80c280943d668395099d3182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755b14bc80c280943d668395099d3182">&#9670;&#160;</a></span>cbegin_samples()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; <a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>, <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a> &gt;::const_iterator <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cbegin_samples </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a constant forward iterator for the sample data. </p>
<p>Sample data is stored as a pair with the first element being the packed integer domain coordinates and the second being the sampled data. </p>

</div>
</div>
<a id="a31c8c29245be671f3858a2fdbb98129e" name="a31c8c29245be671f3858a2fdbb98129e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c8c29245be671f3858a2fdbb98129e">&#9670;&#160;</a></span>cell_can_have_children()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_can_have_children </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell can have children (it not of minimal size) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cb58d06a964c64bb34a8c8703d4a28d" name="a9cb58d06a964c64bb34a8c8703d4a28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb58d06a964c64bb34a8c8703d4a28d">&#9670;&#160;</a></span>cell_corner_is_nan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_corner_is_nan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell has an corner with a NaN value for a sample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7753832f5a627a49ab9f782a7873e81b" name="a7753832f5a627a49ab9f782a7873e81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7753832f5a627a49ab9f782a7873e81b">&#9670;&#160;</a></span>cell_cross_sdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_cross_sdf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#a8ea5fe20e6087596a5f857d88d9ae50c">src_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>signFunc</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell crosses a signed distance function boundry. </p>
<dl class="section warning"><dt>Warning</dt><dd>Incorrect result if ALL vertexes of the cell are zero. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input Cell </td></tr>
    <tr><td class="paramname">signFunc</td><td>Signed distance function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the cell crosses the signed distance function. </dd></dl>

</div>
</div>
<a id="ab2f9261588ee6b95c22275137295c593" name="ab2f9261588ee6b95c22275137295c593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f9261588ee6b95c22275137295c593">&#9670;&#160;</a></span>cell_exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_exists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell has been sampled. </p>
<dl class="section warning"><dt>Warning</dt><dd>Simply checks that cell has been sampled &ndash; identical to <a class="el" href="#aa4209d3fa754d39fb246573f758b5b5b" title="Point has been sampled.">vertex_exists()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9c8af0d576d11517b96dde0783c7b17" name="ad9c8af0d576d11517b96dde0783c7b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c8af0d576d11517b96dde0783c7b17">&#9670;&#160;</a></span>cell_full_width()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_full_width </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute cell full width. </p>
<dl class="section warning"><dt>Warning</dt><dd>No error checking &ndash; cell must be a valid center coordinate. See: cellCordsGood() </dd>
<dd>
Only uses the last iCrdCmp in the cell to compute value. Thus inconsistant components will not be detected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Full width of the given cell. </dd></dl>

</div>
</div>
<a id="a9c7df46004858c6fb20fe08b90f4a0a1" name="a9c7df46004858c6fb20fe08b90f4a0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7df46004858c6fb20fe08b90f4a0a1">&#9670;&#160;</a></span>cell_get_corner_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_get_corner_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cell last corner. </p>
<dl class="section warning"><dt>Warning</dt><dd>No error checking &ndash; cell must be a valid center coordinate. See: cellCordsGood() </dd>
<dd>
Only uses the last iCrdCmp in the cell to compute value. Thus inconsistant components will not be detected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last corner of given cell </dd></dl>

</div>
</div>
<a id="ac7db6390bfa0220ebba1cc31b1e4edd2" name="ac7db6390bfa0220ebba1cc31b1e4edd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7db6390bfa0220ebba1cc31b1e4edd2">&#9670;&#160;</a></span>cell_get_corner_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_get_corner_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cell first corner. </p>
<dl class="section warning"><dt>Warning</dt><dd>No error checking &ndash; cell must be a valid center coordinate. See: cellCordsGood() </dd>
<dd>
Only uses the last iCrdCmp in the cell to compute value. Thus inconsistant components will not be detected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>First corner of given cell </dd></dl>

</div>
</div>
<a id="a8fd1a293eb3d7610ad1c3cfbd9df575b" name="a8fd1a293eb3d7610ad1c3cfbd9df575b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd1a293eb3d7610ad1c3cfbd9df575b">&#9670;&#160;</a></span>cell_good_cords()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_good_cords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if cell coordinates are in range to be a cell center. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if cell is in bounds, false otherwise </dd></dl>

</div>
</div>
<a id="a947b0c2e201510e2b98c60a7d69d9118" name="a947b0c2e201510e2b98c60a7d69d9118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947b0c2e201510e2b98c60a7d69d9118">&#9670;&#160;</a></span>cell_good_samples()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_good_samples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell has been sampled. </p>
<dl class="section warning"><dt>Warning</dt><dd>Simply checks that cell has been sampled &ndash; identical to <a class="el" href="#aa4209d3fa754d39fb246573f758b5b5b" title="Point has been sampled.">vertex_exists()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a674c4274ee2b6704e6f84dc141858ecc" name="a674c4274ee2b6704e6f84dc141858ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674c4274ee2b6704e6f84dc141858ecc">&#9670;&#160;</a></span>cell_half_width()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_half_width </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute cell half width. </p>
<dl class="section warning"><dt>Warning</dt><dd>No error checking &ndash; cell must be a valid center coordinate. See: cellCordsGood() </dd>
<dd>
Only uses the last iCrdCmp in the cell to compute value. Thus inconsistant components will not be detected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Half width of the given cell. </dd></dl>

</div>
</div>
<a id="a9fa6cf0fb08e3f960c9f09fe1b044760" name="a9fa6cf0fb08e3f960c9f09fe1b044760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa6cf0fb08e3f960c9f09fe1b044760">&#9670;&#160;</a></span>cell_has_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_has_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell has children. </p>
<dl class="section warning"><dt>Warning</dt><dd>Assumes the tree is well formed, and only checks that the "lower left" child's center been sampled! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6d727b20bb519caea074c07eeba250b" name="ad6d727b20bb519caea074c07eeba250b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d727b20bb519caea074c07eeba250b">&#9670;&#160;</a></span>cell_has_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_has_neighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if the specified neighbor cell exixts (is smapled). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the axis. Must be in [0, dom_dim-1]. No error checking. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction on the given index. Must be 1 or -1. No error checking. </td></tr>
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39924936ad3a5a8fc897d180efe207e1" name="a39924936ad3a5a8fc897d180efe207e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39924936ad3a5a8fc897d180efe207e1">&#9670;&#160;</a></span>cell_has_no_child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_has_no_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell has no children. </p>
<dl class="section warning"><dt>Warning</dt><dd>Assumes the tree is well formed, and only checks that the "lower left" child's center been sampled! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c79846d5482a3461e2d1ed60c8ecd44" name="a9c79846d5482a3461e2d1ed60c8ecd44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c79846d5482a3461e2d1ed60c8ecd44">&#9670;&#160;</a></span>cell_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute cell level. </p>
<dl class="section warning"><dt>Warning</dt><dd>Cell must be a valid center coordinate. See: cellCordsGood() </dd>
<dd>
Only uses the last iCrdCmp in the cell to compute value. Thus inconsistant components will not be detected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The level of the given cell. </dd></dl>

</div>
</div>
<a id="a35ecfe83bcce1d2c0c726b82bfdf3128" name="a35ecfe83bcce1d2c0c726b82bfdf3128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ecfe83bcce1d2c0c726b82bfdf3128">&#9670;&#160;</a></span>cell_quarter_width()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_quarter_width </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute cell quarter width. </p>
<dl class="section warning"><dt>Warning</dt><dd>No error checking &ndash; cell must be a valid center coordinate. See: cellCordsGood() </dd>
<dd>
Only uses the last iCrdCmp in the cell to compute value. Thus inconsistant components will not be detected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Quarter width of the given cell. </dd></dl>

</div>
</div>
<a id="a5c421066434d14763bde9c364c768b70" name="a5c421066434d14763bde9c364c768b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c421066434d14763bde9c364c768b70">&#9670;&#160;</a></span>cell_vertex_is_nan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cell_vertex_is_nan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a cell has a vertex with a NaN value for a sample. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1c1a0e0ba605f2ff4ebdabd12cb27c0" name="aa1c1a0e0ba605f2ff4ebdabd12cb27c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c1a0e0ba605f2ff4ebdabd12cb27c0">&#9670;&#160;</a></span>cend_samples()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; <a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>, <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a> &gt;::const_iterator <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::cend_samples </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a constant end iterator for the sample data. </p>
<p>see: <a class="el" href="#a755b14bc80c280943d668395099d3182" title="Provide a constant forward iterator for the sample data.">cbegin_samples()</a>. </p>

</div>
</div>
<a id="acf9833d9d86a71b70596fb7f1b3bf237" name="acf9833d9d86a71b70596fb7f1b3bf237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9833d9d86a71b70596fb7f1b3bf237">&#9670;&#160;</a></span>count_leaf_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::count_leaf_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the number of leaf cells starting from the given cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Starting cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18b83e83767379e37bb18b15f856bca8" name="a18b83e83767379e37bb18b15f856bca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b83e83767379e37bb18b15f856bca8">&#9670;&#160;</a></span>dec_all_crd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::dec_all_crd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>diti</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decriment all components in a a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diti</td><td>The input tuple </td></tr>
    <tr><td class="paramname">value</td><td>Amout by which to decrement each component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New tuple with decrimented components </dd></dl>

</div>
</div>
<a id="af31e6c7fe35bbae1c53d9484440e4e78" name="af31e6c7fe35bbae1c53d9484440e4e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af31e6c7fe35bbae1c53d9484440e4e78">&#9670;&#160;</a></span>dec_crd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::dec_crd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>diti</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decriment a component in a a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diti</td><td>The input tuple </td></tr>
    <tr><td class="paramname">index</td><td>Which component to incriment </td></tr>
    <tr><td class="paramname">value</td><td>Amout by which to decrement the component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New tuple with the specified component decrimented </dd></dl>

</div>
</div>
<a id="a96f1e2a8c540677065f7a2b38e139708" name="a96f1e2a8c540677065f7a2b38e139708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f1e2a8c540677065f7a2b38e139708">&#9670;&#160;</a></span>dita_to_diti()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::dita_to_diti </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a05cfe4c14b90a5b6de0d3fc0ff9da55b">dita_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dita</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an vector of integer coordinate tuple to an packed integer coordinate tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dita</td><td>The vector of integer coordinate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New packed integer tuple. </dd></dl>

</div>
</div>
<a id="ab403e84cab06928c29309ba94a1bb4b5" name="ab403e84cab06928c29309ba94a1bb4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab403e84cab06928c29309ba94a1bb4b5">&#9670;&#160;</a></span>diti_to_dita()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a05cfe4c14b90a5b6de0d3fc0ff9da55b">dita_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::diti_to_dita </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>diti</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a packed integer coordinate tuple to a vector of integer coordinate tuple Note dita_t is <em>always</em> a vector even when dom_dim==1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diti</td><td>Packed integer coordinate tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New vector of integer coordinate tuple </dd></dl>

</div>
</div>
<a id="a3534cbe683cd7b487647cdb5f4828ec5" name="a3534cbe683cd7b487647cdb5f4828ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3534cbe683cd7b487647cdb5f4828ec5">&#9670;&#160;</a></span>diti_to_drpt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::diti_to_drpt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>diti</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a packed integer coordinate tuple to the coorisponding coordinate in drpt_t Note this function might return a scalar (float, double, etc...) or a std::vector! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diti</td><td>Input integer tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>domain space value. </dd></dl>

</div>
</div>
<a id="a5cd5439e8b8f8b910c87b544b4a072e1" name="a5cd5439e8b8f8b910c87b544b4a072e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd5439e8b8f8b910c87b544b4a072e1">&#9670;&#160;</a></span>diti_to_drta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a0c405f3fbc8cbe6d263940f9825bc47c">drta_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::diti_to_drta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>diti</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a packed integer coordinate tuple to the coorisponding <em>VECTOR</em> tuple of src_t Unlike diti_to_drpt, this function ALWAYS returns a vector! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diti</td><td>Input integer tuple </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>domain space value. </dd></dl>

</div>
</div>
<a id="aa24ab4fd1dc468fd12741b5f936da140" name="aa24ab4fd1dc468fd12741b5f936da140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24ab4fd1dc468fd12741b5f936da140">&#9670;&#160;</a></span>diti_to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::diti_to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>diti</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>includeDomain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>doHex</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a diti_t to a string representation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diti</td><td>The diti_t to convert </td></tr>
    <tr><td class="paramname">includeDomain</td><td>When true, also include the real coordinates in the string representation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0ad9ca843261c23a08e5e5ecfcc7146" name="aa0ad9ca843261c23a08e5e5ecfcc7146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ad9ca843261c23a08e5e5ecfcc7146">&#9670;&#160;</a></span>dump_tree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::dump_tree </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxNumPrint</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump tree to STDOUT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxNumPrint</td><td>Maximum number of samples to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1086fa9368027d1e3ae8a890a47a702a" name="a1086fa9368027d1e3ae8a890a47a702a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1086fa9368027d1e3ae8a890a47a702a">&#9670;&#160;</a></span>get_axis_cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_axis_cross </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>diti</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a></td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute axis aligned cross points centered at diti and delta away TODO: Should this be private? Axis aligned cross points that fall outside of the domain will not be returned. </p>
<p>For example, if diti=0, then we get no points to the left. Examples:</p><ul>
<li>domDom==1 =&gt; {diti-delta, diti+delta}</li>
<li>domDom==2 =&gt; {diti+[0, -delta], diti+[0, +delta], diti+[-delta, 0], diti+[+delta, 0]}</li>
<li>domDom==3 =&gt; {diti+[0, 0, -delta], diti+[0, 0, +delta], diti+[0, -delta, 0], diti+[0, +delta, 0], diti+[-delta, 0, 0], diti+[+delta, 0, 0]} <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diti</td><td>Center coordinates for the cross </td></tr>
    <tr><td class="paramname">delta</td><td>The Distance for the cross points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last of cross product points </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a3907e8778faa5fa166483328904f0ae6" name="a3907e8778faa5fa166483328904f0ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3907e8778faa5fa166483328904f0ae6">&#9670;&#160;</a></span>get_children() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_children </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of child cells of the specified cell If cell can't have children because it is at maximal depth, then an empty vector is returned. </p>
<dl class="section warning"><dt>Warning</dt><dd>This isn't a check for existing, sampled children &ndash; it simply returns the coordinates of potential children. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a939db86e6333d52cd30b3f6607229873" name="a939db86e6333d52cd30b3f6607229873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939db86e6333d52cd30b3f6607229873">&#9670;&#160;</a></span>get_children() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_children </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of child cells of the specified cell An empty vector is returned if no children are possible. </p>
<dl class="section warning"><dt>Warning</dt><dd>This isn't a check for existing, sampled children &ndash; it simply returns the coordinates of potential children. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
    <tr><td class="paramname">index</td><td>The index of the axis. Must be in [0, dom_dim-1]. No error checking. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction on the given index. Must be 1 or -1. No error checking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08236214e061dba1350a7571767ed858" name="a08236214e061dba1350a7571767ed858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08236214e061dba1350a7571767ed858">&#9670;&#160;</a></span>get_corners() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_corners </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of the corners of the given cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05f9a6878e2c47550c412784f1f06bdd" name="a05f9a6878e2c47550c412784f1f06bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f9a6878e2c47550c412784f1f06bdd">&#9670;&#160;</a></span>get_corners() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_corners </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of the corners of the given cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
    <tr><td class="paramname">index</td><td>The index of the axis. Must be in [0, dom_dim-1]. No error checking. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction on the given index. Must be 1 or -1. No error checking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d9aea0affefa3fc3e8f99fa96266092" name="a8d9aea0affefa3fc3e8f99fa96266092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9aea0affefa3fc3e8f99fa96266092">&#9670;&#160;</a></span>get_crd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_crd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>diti</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a component from a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diti</td><td>The input tuple </td></tr>
    <tr><td class="paramname">index</td><td>Which component to extract </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The component at index position </dd></dl>

</div>
</div>
<a id="aefb1bf963d9e37e1ac5947ab7f93b23a" name="aefb1bf963d9e37e1ac5947ab7f93b23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb1bf963d9e37e1ac5947ab7f93b23a">&#9670;&#160;</a></span>get_existing_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_existing_neighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of sampled neighbors to the given cell. </p>
<dl class="section warning"><dt>Warning</dt><dd>Unlike <a class="el" href="#a468913422a82e42579101305cdbe9f46" title="Return the neighbor cell along the given axis in the specified direction.">get_neighbor()</a>, this member returns a <em>list</em> of <em>existing</em> (sampled) cell centers. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell. Must be a valid cell. &ndash; no error checking. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the axis. Must be in [0, dom_dim-1]. No error checking. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction on the given index. Must be 1 or -1. No error checking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br  />
 </dd></dl>

</div>
</div>
<a id="a6d074ff007886f4a3187c31c20f75d9e" name="a6d074ff007886f4a3187c31c20f75d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d074ff007886f4a3187c31c20f75d9e">&#9670;&#160;</a></span>get_leaf_cells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_leaf_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a list of all leaf cells starting from the given cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Starting cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a764c96e23d3d3fce2ecd638c63f2ce4f" name="a764c96e23d3d3fce2ecd638c63f2ce4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764c96e23d3d3fce2ecd638c63f2ce4f">&#9670;&#160;</a></span>get_leaf_cells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_leaf_cells </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a list of all leaf cells starting from the given cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell. Must be a valid cell. &ndash; no error checking. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the axis. Must be in [0, dom_dim-1]. No error checking. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction on the given index. Must be 1 or -1. No error checking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a468913422a82e42579101305cdbe9f46" name="a468913422a82e42579101305cdbe9f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468913422a82e42579101305cdbe9f46">&#9670;&#160;</a></span>get_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_neighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the neighbor cell along the given axis in the specified direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
    <tr><td class="paramname">index</td><td>The index of the axis. Must be in [0, dom_dim-1]. No error checking. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction on the given index. Must be 1 or -1. No error checking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A neighbor cell coordinate or 0 if no neighbor exists. Note 0 is a valid coordinate, but not the center of any cell. </dd></dl>

</div>
</div>
<a id="afa4b13ba392599dcbfa93bf5e68b5a68" name="afa4b13ba392599dcbfa93bf5e68b5a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa4b13ba392599dcbfa93bf5e68b5a68">&#9670;&#160;</a></span>get_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of neighbor cells of the specified cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae42e967c4706dece9e0fa03f2abba0e" name="aae42e967c4706dece9e0fa03f2abba0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae42e967c4706dece9e0fa03f2abba0e">&#9670;&#160;</a></span>get_sample()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_sample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>vertex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sample value for vertex. </p>
<dl class="section warning"><dt>Warning</dt><dd>Should only be used when the vertex has been sampled! </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>Input vertex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57961e10e2b2a7d118024b1f10f358d5" name="a57961e10e2b2a7d118024b1f10f358d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57961e10e2b2a7d118024b1f10f358d5">&#9670;&#160;</a></span>get_top_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_top_cell </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the top cell coordinates for the tree. </p>
<dl class="section return"><dt>Returns</dt><dd>Top cell coordinate for the tree. </dd></dl>

</div>
</div>
<a id="ac1f3049d5dc8469b96b290c14040808e" name="ac1f3049d5dc8469b96b290c14040808e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f3049d5dc8469b96b290c14040808e">&#9670;&#160;</a></span>get_two_cross() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_two_cross </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>diti</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a></td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute cross product points centered at diti and delta away TODO: Should this be private? TODO: If diti is close to an corner, then some of the cross product points may be out of range. </p>
<p>Add a check for this. Error out or just don't push? Examples:</p><ul>
<li>domDom==1 =&gt; {diti-delta, diti+delta}</li>
<li>domDom==2 =&gt; {diti+[-delta, -delta], diti+[-delta, +delta], diti+[+delta, -delta], diti+[+delta, +delta]}</li>
<li>domDom==3 =&gt; {diti+[-delta, -delta, -delta], ..., diti+[+delta, +delta, +delta]} &ndash; this list will have 8 points <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diti</td><td>Center coordinates for the cross product points </td></tr>
    <tr><td class="paramname">delta</td><td>The Distance for the cross product points </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last of cross product points </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ab29922671bfa697da72c46b613fa9f09" name="ab29922671bfa697da72c46b613fa9f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29922671bfa697da72c46b613fa9f09">&#9670;&#160;</a></span>get_two_cross() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_two_cross </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>diti</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a></td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute directional cross product points centered at diti and delta away. </p>
<dl class="section warning"><dt>Warning</dt><dd>If diti is close to an corner, then some of the cross product points may be out of range! Examples:<ul>
<li>domDom==1, index==0, direction==-1 =&gt; {diti-delta}</li>
<li>domDom==1, index==0, direction== 1 =&gt; {diti+delta}</li>
<li>domDom==2, index==0, direction==-1 =&gt; {diti+[-delta, -delta], diti+[-delta, +delta ]}</li>
<li>domDom==2, index==0, direction== 1 =&gt; { diti+[+delta, -delta], diti+[+delta, +delta]}</li>
<li>domDom==2, index==1, direction==-1 =&gt; {diti+[-delta, -delta], diti+[+delta, -delta] ]}</li>
<li>domDom==2, index==1, direction== 1 =&gt; { diti+[-delta, +delta], diti+[+delta, +delta]} </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diti</td><td>Center coordinates for the cross product points </td></tr>
    <tr><td class="paramname">delta</td><td>The Distance for the cross product points. </td></tr>
    <tr><td class="paramname">index</td><td>The index to hold constant. Must be in [0, domDom-1]. No error checking. </td></tr>
    <tr><td class="paramname">direction</td><td>The direction on the given index. Must be 1 or -1. No error checking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Last of cross product points </dd></dl>

</div>
</div>
<a id="a2c472751d365a54d07de55387bf9ced2" name="a2c472751d365a54d07de55387bf9ced2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c472751d365a54d07de55387bf9ced2">&#9670;&#160;</a></span>get_vertexes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a3afbaf494e81b09b5df44d32706000c9">diti_list_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::get_vertexes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a list of the vertexes (corners and center) of the given cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Input cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a172523e2e85ca845d72a3a6d365eadf6" name="a172523e2e85ca845d72a3a6d365eadf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172523e2e85ca845d72a3a6d365eadf6">&#9670;&#160;</a></span>inc_all_crd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::inc_all_crd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>diti</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Incriment all components in a a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diti</td><td>The input tuple </td></tr>
    <tr><td class="paramname">value</td><td>Amout by which to increment each component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New tuple with incrimented components </dd></dl>

</div>
</div>
<a id="aaf094d9a3cb139f037d777712b1b79c5" name="aaf094d9a3cb139f037d777712b1b79c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf094d9a3cb139f037d777712b1b79c5">&#9670;&#160;</a></span>inc_crd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::inc_crd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>diti</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Incriment a component in a a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diti</td><td>The input tuple </td></tr>
    <tr><td class="paramname">index</td><td>Which component to incriment </td></tr>
    <tr><td class="paramname">value</td><td>Amout by which to increment the component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New tuple with the specified component incrimented </dd></dl>

</div>
</div>
<a id="a83d3c9171a8dc7a657464d83903a434c" name="a83d3c9171a8dc7a657464d83903a434c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d3c9171a8dc7a657464d83903a434c">&#9670;&#160;</a></span>refine_once()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::refine_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refine a cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Cell to refine &ndash; no error checking!! TODO: Add error checking. Return should be 1 if we refined, and 0 else. </td></tr>
    <tr><td class="paramname">func</td><td>Function to use for samples </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a851cd97f67c27024121b1493f94da82e" name="a851cd97f67c27024121b1493f94da82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851cd97f67c27024121b1493f94da82e">&#9670;&#160;</a></span>refine_recursive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::refine_recursive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refine a cell until refined cells reach specified depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Cell to refine </td></tr>
    <tr><td class="paramname">depth</td><td>Maximum depth of refined cells. -1 means refine to the limit. </td></tr>
    <tr><td class="paramname">func</td><td>Function to use for samples </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a409b4f56ff71edb6a528539a39b2e6b0" name="a409b4f56ff71edb6a528539a39b2e6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409b4f56ff71edb6a528539a39b2e6b0">&#9670;&#160;</a></span>refine_recursive_cell_pred()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::refine_recursive_cell_pred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>pred</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refine a cells matching predicate until refined cells reach specified depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Cell to refine </td></tr>
    <tr><td class="paramname">depth</td><td>Maximum depth of refinded cells. -1 means refine to the limit. </td></tr>
    <tr><td class="paramname">func</td><td>Function to use for samples </td></tr>
    <tr><td class="paramname">pred</td><td>Predicate function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ddcfaf68f0fd352edc8c44b7ba3b3ef" name="a0ddcfaf68f0fd352edc8c44b7ba3b3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddcfaf68f0fd352edc8c44b7ba3b3ef">&#9670;&#160;</a></span>refine_recursive_if_cell_vertex_is_nan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::refine_recursive_if_cell_vertex_is_nan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refine a cells with NaNs until refined cells reach specified depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Cell to refine </td></tr>
    <tr><td class="paramname">depth</td><td>Maximum depth of refinded cells. -1 means refine to the limit. </td></tr>
    <tr><td class="paramname">func</td><td>Function to use for samples </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6eecff4d5168731756a7991e63fb0bed" name="a6eecff4d5168731756a7991e63fb0bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eecff4d5168731756a7991e63fb0bed">&#9670;&#160;</a></span>sample_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::sample_cell </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample a cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Cell to sample </td></tr>
    <tr><td class="paramname">func</td><td>Function to use for samples </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc142bafa00a1ae8d627dfe4857156d2" name="abc142bafa00a1ae8d627dfe4857156d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc142bafa00a1ae8d627dfe4857156d2">&#9670;&#160;</a></span>sample_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::sample_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>cell</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample a function uniformly to a given cell depth. </p>
<p>The given cell need not exist in the tree yet. </p><dl class="section warning"><dt>Warning</dt><dd>Optimized to sample cells that have not been sampled previously. </dd>
<dd>
Will resample previously sampled points in the cell. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>THe cell to sample within </td></tr>
    <tr><td class="paramname">depth</td><td>The depth at which to sample depth=0 is equivilent to calling sample_cell(cell, func). depth=1 is equivilent to calling sample_cell(cell, func) followed by refine_once(cell, func). </td></tr>
    <tr><td class="paramname">func</td><td>Function to use for samples </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ce320d58ac8a0954f2364a85c73a6ee" name="a0ce320d58ac8a0954f2364a85c73a6ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce320d58ac8a0954f2364a85c73a6ee">&#9670;&#160;</a></span>sample_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::sample_point </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>diti</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample a point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diti</td><td>Point at which to sample </td></tr>
    <tr><td class="paramname">func</td><td>Function to sample </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2191bd9f101510576b6d188e19263ef8" name="a2191bd9f101510576b6d188e19263ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2191bd9f101510576b6d188e19263ef8">&#9670;&#160;</a></span>sample_point_maybe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::sample_point_maybe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>diti</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; <a class="el" href="#a90cd339df201740643e296d1823c34d5">rrpt_t</a>(<a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sample a point if it has not already been sampled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diti</td><td>Point at which to sample </td></tr>
    <tr><td class="paramname">func</td><td>Function to sample </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we sampled the point, and false otherwise. </dd></dl>

</div>
</div>
<a id="a5e97f695e45c2c005512144a9596e904" name="a5e97f695e45c2c005512144a9596e904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e97f695e45c2c005512144a9596e904">&#9670;&#160;</a></span>set_all_crd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a> <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::set_all_crd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad526d4b1a983fc15420edd0a774309e6">dic_t</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all components in a a tuple to a constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value for each component </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New tuple </dd></dl>

</div>
</div>
<a id="aa6c08270e89c63d78f4c35a7ea922c18" name="aa6c08270e89c63d78f4c35a7ea922c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c08270e89c63d78f4c35a7ea922c18">&#9670;&#160;</a></span>set_aspect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::set_aspect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a></td>          <td class="paramname"><span class="paramname"><em>new_aspect</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the aspect ratio. </p>
<dl class="section warning"><dt>Warning</dt><dd>No error checking &ndash; Correct operation only if all elements are positive and the length is rng_dim </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_aspect</td><td>Value to sue for aspect <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7eae79256bb66862ec2c69375813b7ec" name="a7eae79256bb66862ec2c69375813b7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eae79256bb66862ec2c69375813b7ec">&#9670;&#160;</a></span>set_bbox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::set_bbox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a></td>          <td class="paramname"><span class="paramname"><em>new_bbox_min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a></td>          <td class="paramname"><span class="paramname"><em>new_bbox_max</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_bbox_min</td><td>Value to use for bounding box minimum point </td></tr>
    <tr><td class="paramname">new_bbox_max</td><td>Value to use for bounding box maximum point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad777497717a95a551b04c3b4d8223f14" name="ad777497717a95a551b04c3b4d8223f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad777497717a95a551b04c3b4d8223f14">&#9670;&#160;</a></span>set_bbox_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::set_bbox_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a></td>          <td class="paramname"><span class="paramname"><em>new_bbox_max</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the bounding box max_depth. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_bbox_max</td><td>Value to use for bounding box maximum point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa07ef826ffd6427592276776a743562a" name="aa07ef826ffd6427592276776a743562a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07ef826ffd6427592276776a743562a">&#9670;&#160;</a></span>set_bbox_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::set_bbox_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#acee784e59dea1572dcba405ab36f806d">drpt_t</a></td>          <td class="paramname"><span class="paramname"><em>new_bbox_min</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the bounding box minimum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_bbox_min</td><td>Value to use for bounding box minimum point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8214acaf086127d31e48726a7bed588b" name="a8214acaf086127d31e48726a7bed588b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8214acaf086127d31e48726a7bed588b">&#9670;&#160;</a></span>update_bbox_delta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::update_bbox_delta </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the value of bbox_delta. </p>
<p>Use this after modifying the value of bbox_min or bbox_max. </p>

</div>
</div>
<a id="aa4209d3fa754d39fb246573f758b5b5b" name="aa4209d3fa754d39fb246573f758b5b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4209d3fa754d39fb246573f758b5b5b">&#9670;&#160;</a></span>vertex_exists()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::vertex_exists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>vertex</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Point has been sampled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>Input vertex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c1d32162e94aeeea138def8f0b64ca2" name="a8c1d32162e94aeeea138def8f0b64ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1d32162e94aeeea138def8f0b64ca2">&#9670;&#160;</a></span>vertex_is_nan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::vertex_is_nan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a866da9884b31c85dd487209bb6e0904f">diti_t</a></td>          <td class="paramname"><span class="paramname"><em>vertex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if a vertex is NaN or, when it is a vector, if it contains a NaN element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>Input vertex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a94a9e142dc8061f82e852517784fda84" name="a94a9e142dc8061f82e852517784fda84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a9e142dc8061f82e852517784fda84">&#9670;&#160;</a></span>dic_bits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::dic_bits = max_depth+1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bits used by a single component of an integer coordinate tuple. </p>
<dl class="section warning"><dt>Warning</dt><dd>dic_bits &gt;= sizeof(dic_t), but it might not be equal. </dd></dl>

</div>
</div>
<a id="a08ace574289540a0436f779dd38b506a" name="a08ace574289540a0436f779dd38b506a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ace574289540a0436f779dd38b506a">&#9670;&#160;</a></span>diti_bits</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int max_depth, class spc_real_t , int dom_dim, int rng_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmjr_1_1_m_r__rect__tree.html">mjr::MR_rect_tree</a>&lt; max_depth, spc_real_t, dom_dim, rng_dim &gt;::diti_bits = <a class="el" href="#a94a9e142dc8061f82e852517784fda84">dic_bits</a> * dom_dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of bits used by an entire integer coordinate tuple. </p>
<dl class="section warning"><dt>Warning</dt><dd>diti_bits &gt;= sizeof(diti_t), but it might not be equal. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src_lib/<a class="el" href="_m_r__rect__tree_8hpp_source.html">MR_rect_tree.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
